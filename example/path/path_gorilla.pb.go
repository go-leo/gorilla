// Code generated by protoc-gen-gorilla. DO NOT EDIT.

package path

import (
	context "context"
	gorilla "github.com/go-leo/gorilla"
	mux "github.com/gorilla/mux"
	httpbody "google.golang.org/genproto/googleapis/api/httpbody"
	protojson "google.golang.org/protobuf/encoding/protojson"
	proto "google.golang.org/protobuf/proto"
	wrapperspb "google.golang.org/protobuf/types/known/wrapperspb"
	http "net/http"
)

type BoolPathGorillaService interface {
	BoolPath(ctx context.Context, request *BoolPathRequest) (*httpbody.HttpBody, error)
}

func AppendBoolPathGorillaRoute(router *mux.Router, service BoolPathGorillaService, opts ...gorilla.Option) *mux.Router {
	options := gorilla.NewOptions(opts...)
	handler := boolPathGorillaHandler{
		service: service,
		decoder: boolPathGorillaRequestDecoder{
			unmarshalOptions: options.UnmarshalOptions(),
		},
		encoder: boolPathGorillaResponseEncoder{
			marshalOptions:      options.MarshalOptions(),
			unmarshalOptions:    options.UnmarshalOptions(),
			responseTransformer: options.ResponseTransformer(),
		},
		errorEncoder:            gorilla.DefaultEncodeError,
		shouldFailFast:          options.ShouldFailFast(),
		onValidationErrCallback: options.OnValidationErrCallback(),
	}
	router.NewRoute().
		Name("/leo.gorilla.example.path.v1.BoolPath/BoolPath").
		Methods("GET").
		Path("/v1/{bool}/{opt_bool}/{wrap_bool}").
		Handler(gorilla.Chain(handler.BoolPath(), options.Middlewares()...))
	return router
}

type boolPathGorillaHandler struct {
	service                 BoolPathGorillaService
	decoder                 boolPathGorillaRequestDecoder
	encoder                 boolPathGorillaResponseEncoder
	errorEncoder            gorilla.ErrorEncoder
	shouldFailFast          bool
	onValidationErrCallback gorilla.OnValidationErrCallback
}

func (h boolPathGorillaHandler) BoolPath() http.Handler {
	return http.HandlerFunc(func(writer http.ResponseWriter, request *http.Request) {
		ctx := request.Context()
		in, err := h.decoder.BoolPath(ctx, request)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		if err := gorilla.ValidateRequest(ctx, in, h.shouldFailFast, h.onValidationErrCallback); err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		out, err := h.service.BoolPath(ctx, in)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		if err := h.encoder.BoolPath(ctx, writer, out); err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
	})
}

type boolPathGorillaRequestDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder boolPathGorillaRequestDecoder) BoolPath(ctx context.Context, r *http.Request) (*BoolPathRequest, error) {
	req := &BoolPathRequest{}
	ok, err := gorilla.CustomDecodeRequest(ctx, r, req)
	if err != nil {
		return nil, err
	}
	if ok {
		return req, nil
	}
	vars := gorilla.FormFromMap(mux.Vars(r))
	var varErr error
	req.Bool, varErr = gorilla.DecodeForm[bool](varErr, vars, "bool", gorilla.GetBool)
	req.OptBool, varErr = gorilla.DecodeForm[*bool](varErr, vars, "opt_bool", gorilla.GetBoolPtr)
	req.WrapBool, varErr = gorilla.DecodeForm[*wrapperspb.BoolValue](varErr, vars, "wrap_bool", gorilla.GetBoolValue)
	req.Bool, varErr = gorilla.DecodeForm[bool](varErr, vars, "bool", gorilla.GetBool)
	req.OptBool, varErr = gorilla.DecodeForm[*bool](varErr, vars, "opt_bool", gorilla.GetBoolPtr)
	req.WrapBool, varErr = gorilla.DecodeForm[*wrapperspb.BoolValue](varErr, vars, "wrap_bool", gorilla.GetBoolValue)
	if varErr != nil {
		return nil, varErr
	}
	return req, nil
}

type boolPathGorillaResponseEncoder struct {
	marshalOptions      protojson.MarshalOptions
	unmarshalOptions    protojson.UnmarshalOptions
	responseTransformer gorilla.ResponseTransformer
}

func (encoder boolPathGorillaResponseEncoder) BoolPath(ctx context.Context, w http.ResponseWriter, resp *httpbody.HttpBody) error {
	return gorilla.EncodeHttpBody(ctx, w, resp)
}

type boolPathGorillaClient struct {
	client                  *http.Client
	encoder                 boolPathGorillaRequestEncoder
	decoder                 boolPathGorillaResponseDecoder
	shouldFailFast          bool
	onValidationErrCallback gorilla.OnValidationErrCallback
}

func (c *boolPathGorillaClient) BoolPath(ctx context.Context, in *BoolPathRequest) (*httpbody.HttpBody, error) {
	if err := gorilla.ValidateRequest(ctx, in, c.shouldFailFast, c.onValidationErrCallback); err != nil {
		return nil, err
	}
	req, err := c.encoder.BoolPath(ctx, in)
	if err != nil {
		return nil, err
	}
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, err
	}
	out, err := c.decoder.BoolPath(ctx, resp)
	if err != nil {
		return nil, err
	}
	return out, nil
}

type boolPathGorillaRequestEncoder struct {
}

func (c *boolPathGorillaRequestEncoder) BoolPath(ctx context.Context, request *BoolPathRequest) (*http.Request, error) {
	return nil, nil
}

type boolPathGorillaResponseDecoder struct {
}

func (c *boolPathGorillaResponseDecoder) BoolPath(ctx context.Context, response *http.Response) (*httpbody.HttpBody, error) {
	return nil, nil
}

type Int32PathGorillaService interface {
	Int32Path(ctx context.Context, request *Int32PathRequest) (*httpbody.HttpBody, error)
}

func AppendInt32PathGorillaRoute(router *mux.Router, service Int32PathGorillaService, opts ...gorilla.Option) *mux.Router {
	options := gorilla.NewOptions(opts...)
	handler := int32PathGorillaHandler{
		service: service,
		decoder: int32PathGorillaRequestDecoder{
			unmarshalOptions: options.UnmarshalOptions(),
		},
		encoder: int32PathGorillaResponseEncoder{
			marshalOptions:      options.MarshalOptions(),
			unmarshalOptions:    options.UnmarshalOptions(),
			responseTransformer: options.ResponseTransformer(),
		},
		errorEncoder:            gorilla.DefaultEncodeError,
		shouldFailFast:          options.ShouldFailFast(),
		onValidationErrCallback: options.OnValidationErrCallback(),
	}
	router.NewRoute().
		Name("/leo.gorilla.example.path.v1.Int32Path/Int32Path").
		Methods("GET").
		Path("/v1/{int32}/{sint32}/{sfixed32}/{opt_int32}/{opt_sint32}/{opt_sfixed32}/{wrap_int32}").
		Handler(gorilla.Chain(handler.Int32Path(), options.Middlewares()...))
	return router
}

type int32PathGorillaHandler struct {
	service                 Int32PathGorillaService
	decoder                 int32PathGorillaRequestDecoder
	encoder                 int32PathGorillaResponseEncoder
	errorEncoder            gorilla.ErrorEncoder
	shouldFailFast          bool
	onValidationErrCallback gorilla.OnValidationErrCallback
}

func (h int32PathGorillaHandler) Int32Path() http.Handler {
	return http.HandlerFunc(func(writer http.ResponseWriter, request *http.Request) {
		ctx := request.Context()
		in, err := h.decoder.Int32Path(ctx, request)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		if err := gorilla.ValidateRequest(ctx, in, h.shouldFailFast, h.onValidationErrCallback); err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		out, err := h.service.Int32Path(ctx, in)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		if err := h.encoder.Int32Path(ctx, writer, out); err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
	})
}

type int32PathGorillaRequestDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder int32PathGorillaRequestDecoder) Int32Path(ctx context.Context, r *http.Request) (*Int32PathRequest, error) {
	req := &Int32PathRequest{}
	ok, err := gorilla.CustomDecodeRequest(ctx, r, req)
	if err != nil {
		return nil, err
	}
	if ok {
		return req, nil
	}
	vars := gorilla.FormFromMap(mux.Vars(r))
	var varErr error
	req.Int32, varErr = gorilla.DecodeForm[int32](varErr, vars, "int32", gorilla.GetInt32)
	req.Sint32, varErr = gorilla.DecodeForm[int32](varErr, vars, "sint32", gorilla.GetInt32)
	req.Sfixed32, varErr = gorilla.DecodeForm[int32](varErr, vars, "sfixed32", gorilla.GetInt32)
	req.OptInt32, varErr = gorilla.DecodeForm[*int32](varErr, vars, "opt_int32", gorilla.GetInt32Ptr)
	req.OptSint32, varErr = gorilla.DecodeForm[*int32](varErr, vars, "opt_sint32", gorilla.GetInt32Ptr)
	req.OptSfixed32, varErr = gorilla.DecodeForm[*int32](varErr, vars, "opt_sfixed32", gorilla.GetInt32Ptr)
	req.WrapInt32, varErr = gorilla.DecodeForm[*wrapperspb.Int32Value](varErr, vars, "wrap_int32", gorilla.GetInt32Value)
	req.Int32, varErr = gorilla.DecodeForm[int32](varErr, vars, "int32", gorilla.GetInt32)
	req.Sint32, varErr = gorilla.DecodeForm[int32](varErr, vars, "sint32", gorilla.GetInt32)
	req.Sfixed32, varErr = gorilla.DecodeForm[int32](varErr, vars, "sfixed32", gorilla.GetInt32)
	req.OptInt32, varErr = gorilla.DecodeForm[*int32](varErr, vars, "opt_int32", gorilla.GetInt32Ptr)
	req.OptSint32, varErr = gorilla.DecodeForm[*int32](varErr, vars, "opt_sint32", gorilla.GetInt32Ptr)
	req.OptSfixed32, varErr = gorilla.DecodeForm[*int32](varErr, vars, "opt_sfixed32", gorilla.GetInt32Ptr)
	req.WrapInt32, varErr = gorilla.DecodeForm[*wrapperspb.Int32Value](varErr, vars, "wrap_int32", gorilla.GetInt32Value)
	if varErr != nil {
		return nil, varErr
	}
	return req, nil
}

type int32PathGorillaResponseEncoder struct {
	marshalOptions      protojson.MarshalOptions
	unmarshalOptions    protojson.UnmarshalOptions
	responseTransformer gorilla.ResponseTransformer
}

func (encoder int32PathGorillaResponseEncoder) Int32Path(ctx context.Context, w http.ResponseWriter, resp *httpbody.HttpBody) error {
	return gorilla.EncodeHttpBody(ctx, w, resp)
}

type int32PathGorillaClient struct {
	client                  *http.Client
	encoder                 int32PathGorillaRequestEncoder
	decoder                 int32PathGorillaResponseDecoder
	shouldFailFast          bool
	onValidationErrCallback gorilla.OnValidationErrCallback
}

func (c *int32PathGorillaClient) Int32Path(ctx context.Context, in *Int32PathRequest) (*httpbody.HttpBody, error) {
	if err := gorilla.ValidateRequest(ctx, in, c.shouldFailFast, c.onValidationErrCallback); err != nil {
		return nil, err
	}
	req, err := c.encoder.Int32Path(ctx, in)
	if err != nil {
		return nil, err
	}
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, err
	}
	out, err := c.decoder.Int32Path(ctx, resp)
	if err != nil {
		return nil, err
	}
	return out, nil
}

type int32PathGorillaRequestEncoder struct {
}

func (c *int32PathGorillaRequestEncoder) Int32Path(ctx context.Context, request *Int32PathRequest) (*http.Request, error) {
	return nil, nil
}

type int32PathGorillaResponseDecoder struct {
}

func (c *int32PathGorillaResponseDecoder) Int32Path(ctx context.Context, response *http.Response) (*httpbody.HttpBody, error) {
	return nil, nil
}

type Int64PathGorillaService interface {
	Int64Path(ctx context.Context, request *Int64PathRequest) (*httpbody.HttpBody, error)
}

func AppendInt64PathGorillaRoute(router *mux.Router, service Int64PathGorillaService, opts ...gorilla.Option) *mux.Router {
	options := gorilla.NewOptions(opts...)
	handler := int64PathGorillaHandler{
		service: service,
		decoder: int64PathGorillaRequestDecoder{
			unmarshalOptions: options.UnmarshalOptions(),
		},
		encoder: int64PathGorillaResponseEncoder{
			marshalOptions:      options.MarshalOptions(),
			unmarshalOptions:    options.UnmarshalOptions(),
			responseTransformer: options.ResponseTransformer(),
		},
		errorEncoder:            gorilla.DefaultEncodeError,
		shouldFailFast:          options.ShouldFailFast(),
		onValidationErrCallback: options.OnValidationErrCallback(),
	}
	router.NewRoute().
		Name("/leo.gorilla.example.path.v1.Int64Path/Int64Path").
		Methods("GET").
		Path("/v1/{int64}/{sint64}/{sfixed64}/{opt_int64}/{opt_sint64}/{opt_sfixed64}/{wrap_int64}").
		Handler(gorilla.Chain(handler.Int64Path(), options.Middlewares()...))
	return router
}

type int64PathGorillaHandler struct {
	service                 Int64PathGorillaService
	decoder                 int64PathGorillaRequestDecoder
	encoder                 int64PathGorillaResponseEncoder
	errorEncoder            gorilla.ErrorEncoder
	shouldFailFast          bool
	onValidationErrCallback gorilla.OnValidationErrCallback
}

func (h int64PathGorillaHandler) Int64Path() http.Handler {
	return http.HandlerFunc(func(writer http.ResponseWriter, request *http.Request) {
		ctx := request.Context()
		in, err := h.decoder.Int64Path(ctx, request)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		if err := gorilla.ValidateRequest(ctx, in, h.shouldFailFast, h.onValidationErrCallback); err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		out, err := h.service.Int64Path(ctx, in)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		if err := h.encoder.Int64Path(ctx, writer, out); err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
	})
}

type int64PathGorillaRequestDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder int64PathGorillaRequestDecoder) Int64Path(ctx context.Context, r *http.Request) (*Int64PathRequest, error) {
	req := &Int64PathRequest{}
	ok, err := gorilla.CustomDecodeRequest(ctx, r, req)
	if err != nil {
		return nil, err
	}
	if ok {
		return req, nil
	}
	vars := gorilla.FormFromMap(mux.Vars(r))
	var varErr error
	req.Int64, varErr = gorilla.DecodeForm[int64](varErr, vars, "int64", gorilla.GetInt64)
	req.Sint64, varErr = gorilla.DecodeForm[int64](varErr, vars, "sint64", gorilla.GetInt64)
	req.Sfixed64, varErr = gorilla.DecodeForm[int64](varErr, vars, "sfixed64", gorilla.GetInt64)
	req.OptInt64, varErr = gorilla.DecodeForm[*int64](varErr, vars, "opt_int64", gorilla.GetInt64Ptr)
	req.OptSint64, varErr = gorilla.DecodeForm[*int64](varErr, vars, "opt_sint64", gorilla.GetInt64Ptr)
	req.OptSfixed64, varErr = gorilla.DecodeForm[*int64](varErr, vars, "opt_sfixed64", gorilla.GetInt64Ptr)
	req.WrapInt64, varErr = gorilla.DecodeForm[*wrapperspb.Int64Value](varErr, vars, "wrap_int64", gorilla.GetInt64Value)
	req.Int64, varErr = gorilla.DecodeForm[int64](varErr, vars, "int64", gorilla.GetInt64)
	req.Sint64, varErr = gorilla.DecodeForm[int64](varErr, vars, "sint64", gorilla.GetInt64)
	req.Sfixed64, varErr = gorilla.DecodeForm[int64](varErr, vars, "sfixed64", gorilla.GetInt64)
	req.OptInt64, varErr = gorilla.DecodeForm[*int64](varErr, vars, "opt_int64", gorilla.GetInt64Ptr)
	req.OptSint64, varErr = gorilla.DecodeForm[*int64](varErr, vars, "opt_sint64", gorilla.GetInt64Ptr)
	req.OptSfixed64, varErr = gorilla.DecodeForm[*int64](varErr, vars, "opt_sfixed64", gorilla.GetInt64Ptr)
	req.WrapInt64, varErr = gorilla.DecodeForm[*wrapperspb.Int64Value](varErr, vars, "wrap_int64", gorilla.GetInt64Value)
	if varErr != nil {
		return nil, varErr
	}
	return req, nil
}

type int64PathGorillaResponseEncoder struct {
	marshalOptions      protojson.MarshalOptions
	unmarshalOptions    protojson.UnmarshalOptions
	responseTransformer gorilla.ResponseTransformer
}

func (encoder int64PathGorillaResponseEncoder) Int64Path(ctx context.Context, w http.ResponseWriter, resp *httpbody.HttpBody) error {
	return gorilla.EncodeHttpBody(ctx, w, resp)
}

type int64PathGorillaClient struct {
	client                  *http.Client
	encoder                 int64PathGorillaRequestEncoder
	decoder                 int64PathGorillaResponseDecoder
	shouldFailFast          bool
	onValidationErrCallback gorilla.OnValidationErrCallback
}

func (c *int64PathGorillaClient) Int64Path(ctx context.Context, in *Int64PathRequest) (*httpbody.HttpBody, error) {
	if err := gorilla.ValidateRequest(ctx, in, c.shouldFailFast, c.onValidationErrCallback); err != nil {
		return nil, err
	}
	req, err := c.encoder.Int64Path(ctx, in)
	if err != nil {
		return nil, err
	}
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, err
	}
	out, err := c.decoder.Int64Path(ctx, resp)
	if err != nil {
		return nil, err
	}
	return out, nil
}

type int64PathGorillaRequestEncoder struct {
}

func (c *int64PathGorillaRequestEncoder) Int64Path(ctx context.Context, request *Int64PathRequest) (*http.Request, error) {
	return nil, nil
}

type int64PathGorillaResponseDecoder struct {
}

func (c *int64PathGorillaResponseDecoder) Int64Path(ctx context.Context, response *http.Response) (*httpbody.HttpBody, error) {
	return nil, nil
}

type Uint32PathGorillaService interface {
	Uint32Path(ctx context.Context, request *Uint32PathRequest) (*httpbody.HttpBody, error)
}

func AppendUint32PathGorillaRoute(router *mux.Router, service Uint32PathGorillaService, opts ...gorilla.Option) *mux.Router {
	options := gorilla.NewOptions(opts...)
	handler := uint32PathGorillaHandler{
		service: service,
		decoder: uint32PathGorillaRequestDecoder{
			unmarshalOptions: options.UnmarshalOptions(),
		},
		encoder: uint32PathGorillaResponseEncoder{
			marshalOptions:      options.MarshalOptions(),
			unmarshalOptions:    options.UnmarshalOptions(),
			responseTransformer: options.ResponseTransformer(),
		},
		errorEncoder:            gorilla.DefaultEncodeError,
		shouldFailFast:          options.ShouldFailFast(),
		onValidationErrCallback: options.OnValidationErrCallback(),
	}
	router.NewRoute().
		Name("/leo.gorilla.example.path.v1.Uint32Path/Uint32Path").
		Methods("GET").
		Path("/v1/{uint32}/{fixed32}/{opt_uint32}/{opt_fixed32}/{wrap_uint32}").
		Handler(gorilla.Chain(handler.Uint32Path(), options.Middlewares()...))
	return router
}

type uint32PathGorillaHandler struct {
	service                 Uint32PathGorillaService
	decoder                 uint32PathGorillaRequestDecoder
	encoder                 uint32PathGorillaResponseEncoder
	errorEncoder            gorilla.ErrorEncoder
	shouldFailFast          bool
	onValidationErrCallback gorilla.OnValidationErrCallback
}

func (h uint32PathGorillaHandler) Uint32Path() http.Handler {
	return http.HandlerFunc(func(writer http.ResponseWriter, request *http.Request) {
		ctx := request.Context()
		in, err := h.decoder.Uint32Path(ctx, request)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		if err := gorilla.ValidateRequest(ctx, in, h.shouldFailFast, h.onValidationErrCallback); err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		out, err := h.service.Uint32Path(ctx, in)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		if err := h.encoder.Uint32Path(ctx, writer, out); err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
	})
}

type uint32PathGorillaRequestDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder uint32PathGorillaRequestDecoder) Uint32Path(ctx context.Context, r *http.Request) (*Uint32PathRequest, error) {
	req := &Uint32PathRequest{}
	ok, err := gorilla.CustomDecodeRequest(ctx, r, req)
	if err != nil {
		return nil, err
	}
	if ok {
		return req, nil
	}
	vars := gorilla.FormFromMap(mux.Vars(r))
	var varErr error
	req.Uint32, varErr = gorilla.DecodeForm[uint32](varErr, vars, "uint32", gorilla.GetUint32)
	req.Fixed32, varErr = gorilla.DecodeForm[uint32](varErr, vars, "fixed32", gorilla.GetUint32)
	req.OptUint32, varErr = gorilla.DecodeForm[*uint32](varErr, vars, "opt_uint32", gorilla.GetUint32Ptr)
	req.OptFixed32, varErr = gorilla.DecodeForm[*uint32](varErr, vars, "opt_fixed32", gorilla.GetUint32Ptr)
	req.WrapUint32, varErr = gorilla.DecodeForm[*wrapperspb.UInt32Value](varErr, vars, "wrap_uint32", gorilla.GetUint32Value)
	req.Uint32, varErr = gorilla.DecodeForm[uint32](varErr, vars, "uint32", gorilla.GetUint32)
	req.Fixed32, varErr = gorilla.DecodeForm[uint32](varErr, vars, "fixed32", gorilla.GetUint32)
	req.OptUint32, varErr = gorilla.DecodeForm[*uint32](varErr, vars, "opt_uint32", gorilla.GetUint32Ptr)
	req.OptFixed32, varErr = gorilla.DecodeForm[*uint32](varErr, vars, "opt_fixed32", gorilla.GetUint32Ptr)
	req.WrapUint32, varErr = gorilla.DecodeForm[*wrapperspb.UInt32Value](varErr, vars, "wrap_uint32", gorilla.GetUint32Value)
	if varErr != nil {
		return nil, varErr
	}
	return req, nil
}

type uint32PathGorillaResponseEncoder struct {
	marshalOptions      protojson.MarshalOptions
	unmarshalOptions    protojson.UnmarshalOptions
	responseTransformer gorilla.ResponseTransformer
}

func (encoder uint32PathGorillaResponseEncoder) Uint32Path(ctx context.Context, w http.ResponseWriter, resp *httpbody.HttpBody) error {
	return gorilla.EncodeHttpBody(ctx, w, resp)
}

type uint32PathGorillaClient struct {
	client                  *http.Client
	encoder                 uint32PathGorillaRequestEncoder
	decoder                 uint32PathGorillaResponseDecoder
	shouldFailFast          bool
	onValidationErrCallback gorilla.OnValidationErrCallback
}

func (c *uint32PathGorillaClient) Uint32Path(ctx context.Context, in *Uint32PathRequest) (*httpbody.HttpBody, error) {
	if err := gorilla.ValidateRequest(ctx, in, c.shouldFailFast, c.onValidationErrCallback); err != nil {
		return nil, err
	}
	req, err := c.encoder.Uint32Path(ctx, in)
	if err != nil {
		return nil, err
	}
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, err
	}
	out, err := c.decoder.Uint32Path(ctx, resp)
	if err != nil {
		return nil, err
	}
	return out, nil
}

type uint32PathGorillaRequestEncoder struct {
}

func (c *uint32PathGorillaRequestEncoder) Uint32Path(ctx context.Context, request *Uint32PathRequest) (*http.Request, error) {
	return nil, nil
}

type uint32PathGorillaResponseDecoder struct {
}

func (c *uint32PathGorillaResponseDecoder) Uint32Path(ctx context.Context, response *http.Response) (*httpbody.HttpBody, error) {
	return nil, nil
}

type Uint64PathGorillaService interface {
	Uint64Path(ctx context.Context, request *Uint64PathRequest) (*httpbody.HttpBody, error)
}

func AppendUint64PathGorillaRoute(router *mux.Router, service Uint64PathGorillaService, opts ...gorilla.Option) *mux.Router {
	options := gorilla.NewOptions(opts...)
	handler := uint64PathGorillaHandler{
		service: service,
		decoder: uint64PathGorillaRequestDecoder{
			unmarshalOptions: options.UnmarshalOptions(),
		},
		encoder: uint64PathGorillaResponseEncoder{
			marshalOptions:      options.MarshalOptions(),
			unmarshalOptions:    options.UnmarshalOptions(),
			responseTransformer: options.ResponseTransformer(),
		},
		errorEncoder:            gorilla.DefaultEncodeError,
		shouldFailFast:          options.ShouldFailFast(),
		onValidationErrCallback: options.OnValidationErrCallback(),
	}
	router.NewRoute().
		Name("/leo.gorilla.example.path.v1.Uint64Path/Uint64Path").
		Methods("GET").
		Path("/v1/{uint64}/{fixed64}/{opt_uint64}/{opt_fixed64}/{wrap_uint64}").
		Handler(gorilla.Chain(handler.Uint64Path(), options.Middlewares()...))
	return router
}

type uint64PathGorillaHandler struct {
	service                 Uint64PathGorillaService
	decoder                 uint64PathGorillaRequestDecoder
	encoder                 uint64PathGorillaResponseEncoder
	errorEncoder            gorilla.ErrorEncoder
	shouldFailFast          bool
	onValidationErrCallback gorilla.OnValidationErrCallback
}

func (h uint64PathGorillaHandler) Uint64Path() http.Handler {
	return http.HandlerFunc(func(writer http.ResponseWriter, request *http.Request) {
		ctx := request.Context()
		in, err := h.decoder.Uint64Path(ctx, request)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		if err := gorilla.ValidateRequest(ctx, in, h.shouldFailFast, h.onValidationErrCallback); err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		out, err := h.service.Uint64Path(ctx, in)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		if err := h.encoder.Uint64Path(ctx, writer, out); err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
	})
}

type uint64PathGorillaRequestDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder uint64PathGorillaRequestDecoder) Uint64Path(ctx context.Context, r *http.Request) (*Uint64PathRequest, error) {
	req := &Uint64PathRequest{}
	ok, err := gorilla.CustomDecodeRequest(ctx, r, req)
	if err != nil {
		return nil, err
	}
	if ok {
		return req, nil
	}
	vars := gorilla.FormFromMap(mux.Vars(r))
	var varErr error
	req.Uint64, varErr = gorilla.DecodeForm[uint64](varErr, vars, "uint64", gorilla.GetUint64)
	req.Fixed64, varErr = gorilla.DecodeForm[uint64](varErr, vars, "fixed64", gorilla.GetUint64)
	req.OptUint64, varErr = gorilla.DecodeForm[*uint64](varErr, vars, "opt_uint64", gorilla.GetUint64Ptr)
	req.OptFixed64, varErr = gorilla.DecodeForm[*uint64](varErr, vars, "opt_fixed64", gorilla.GetUint64Ptr)
	req.WrapUint64, varErr = gorilla.DecodeForm[*wrapperspb.UInt64Value](varErr, vars, "wrap_uint64", gorilla.GetUint64Value)
	req.Uint64, varErr = gorilla.DecodeForm[uint64](varErr, vars, "uint64", gorilla.GetUint64)
	req.Fixed64, varErr = gorilla.DecodeForm[uint64](varErr, vars, "fixed64", gorilla.GetUint64)
	req.OptUint64, varErr = gorilla.DecodeForm[*uint64](varErr, vars, "opt_uint64", gorilla.GetUint64Ptr)
	req.OptFixed64, varErr = gorilla.DecodeForm[*uint64](varErr, vars, "opt_fixed64", gorilla.GetUint64Ptr)
	req.WrapUint64, varErr = gorilla.DecodeForm[*wrapperspb.UInt64Value](varErr, vars, "wrap_uint64", gorilla.GetUint64Value)
	if varErr != nil {
		return nil, varErr
	}
	return req, nil
}

type uint64PathGorillaResponseEncoder struct {
	marshalOptions      protojson.MarshalOptions
	unmarshalOptions    protojson.UnmarshalOptions
	responseTransformer gorilla.ResponseTransformer
}

func (encoder uint64PathGorillaResponseEncoder) Uint64Path(ctx context.Context, w http.ResponseWriter, resp *httpbody.HttpBody) error {
	return gorilla.EncodeHttpBody(ctx, w, resp)
}

type uint64PathGorillaClient struct {
	client                  *http.Client
	encoder                 uint64PathGorillaRequestEncoder
	decoder                 uint64PathGorillaResponseDecoder
	shouldFailFast          bool
	onValidationErrCallback gorilla.OnValidationErrCallback
}

func (c *uint64PathGorillaClient) Uint64Path(ctx context.Context, in *Uint64PathRequest) (*httpbody.HttpBody, error) {
	if err := gorilla.ValidateRequest(ctx, in, c.shouldFailFast, c.onValidationErrCallback); err != nil {
		return nil, err
	}
	req, err := c.encoder.Uint64Path(ctx, in)
	if err != nil {
		return nil, err
	}
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, err
	}
	out, err := c.decoder.Uint64Path(ctx, resp)
	if err != nil {
		return nil, err
	}
	return out, nil
}

type uint64PathGorillaRequestEncoder struct {
}

func (c *uint64PathGorillaRequestEncoder) Uint64Path(ctx context.Context, request *Uint64PathRequest) (*http.Request, error) {
	return nil, nil
}

type uint64PathGorillaResponseDecoder struct {
}

func (c *uint64PathGorillaResponseDecoder) Uint64Path(ctx context.Context, response *http.Response) (*httpbody.HttpBody, error) {
	return nil, nil
}

type FloatPathGorillaService interface {
	FloatPath(ctx context.Context, request *FloatPathRequest) (*httpbody.HttpBody, error)
}

func AppendFloatPathGorillaRoute(router *mux.Router, service FloatPathGorillaService, opts ...gorilla.Option) *mux.Router {
	options := gorilla.NewOptions(opts...)
	handler := floatPathGorillaHandler{
		service: service,
		decoder: floatPathGorillaRequestDecoder{
			unmarshalOptions: options.UnmarshalOptions(),
		},
		encoder: floatPathGorillaResponseEncoder{
			marshalOptions:      options.MarshalOptions(),
			unmarshalOptions:    options.UnmarshalOptions(),
			responseTransformer: options.ResponseTransformer(),
		},
		errorEncoder:            gorilla.DefaultEncodeError,
		shouldFailFast:          options.ShouldFailFast(),
		onValidationErrCallback: options.OnValidationErrCallback(),
	}
	router.NewRoute().
		Name("/leo.gorilla.example.path.v1.FloatPath/FloatPath").
		Methods("GET").
		Path("/v1/{float}/{opt_float}/{wrap_float}").
		Handler(gorilla.Chain(handler.FloatPath(), options.Middlewares()...))
	return router
}

type floatPathGorillaHandler struct {
	service                 FloatPathGorillaService
	decoder                 floatPathGorillaRequestDecoder
	encoder                 floatPathGorillaResponseEncoder
	errorEncoder            gorilla.ErrorEncoder
	shouldFailFast          bool
	onValidationErrCallback gorilla.OnValidationErrCallback
}

func (h floatPathGorillaHandler) FloatPath() http.Handler {
	return http.HandlerFunc(func(writer http.ResponseWriter, request *http.Request) {
		ctx := request.Context()
		in, err := h.decoder.FloatPath(ctx, request)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		if err := gorilla.ValidateRequest(ctx, in, h.shouldFailFast, h.onValidationErrCallback); err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		out, err := h.service.FloatPath(ctx, in)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		if err := h.encoder.FloatPath(ctx, writer, out); err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
	})
}

type floatPathGorillaRequestDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder floatPathGorillaRequestDecoder) FloatPath(ctx context.Context, r *http.Request) (*FloatPathRequest, error) {
	req := &FloatPathRequest{}
	ok, err := gorilla.CustomDecodeRequest(ctx, r, req)
	if err != nil {
		return nil, err
	}
	if ok {
		return req, nil
	}
	vars := gorilla.FormFromMap(mux.Vars(r))
	var varErr error
	req.Float, varErr = gorilla.DecodeForm[float32](varErr, vars, "float", gorilla.GetFloat32)
	req.OptFloat, varErr = gorilla.DecodeForm[*float32](varErr, vars, "opt_float", gorilla.GetFloat32Ptr)
	req.WrapFloat, varErr = gorilla.DecodeForm[*wrapperspb.FloatValue](varErr, vars, "wrap_float", gorilla.GetFloat32Value)
	req.Float, varErr = gorilla.DecodeForm[float32](varErr, vars, "float", gorilla.GetFloat32)
	req.OptFloat, varErr = gorilla.DecodeForm[*float32](varErr, vars, "opt_float", gorilla.GetFloat32Ptr)
	req.WrapFloat, varErr = gorilla.DecodeForm[*wrapperspb.FloatValue](varErr, vars, "wrap_float", gorilla.GetFloat32Value)
	if varErr != nil {
		return nil, varErr
	}
	return req, nil
}

type floatPathGorillaResponseEncoder struct {
	marshalOptions      protojson.MarshalOptions
	unmarshalOptions    protojson.UnmarshalOptions
	responseTransformer gorilla.ResponseTransformer
}

func (encoder floatPathGorillaResponseEncoder) FloatPath(ctx context.Context, w http.ResponseWriter, resp *httpbody.HttpBody) error {
	return gorilla.EncodeHttpBody(ctx, w, resp)
}

type floatPathGorillaClient struct {
	client                  *http.Client
	encoder                 floatPathGorillaRequestEncoder
	decoder                 floatPathGorillaResponseDecoder
	shouldFailFast          bool
	onValidationErrCallback gorilla.OnValidationErrCallback
}

func (c *floatPathGorillaClient) FloatPath(ctx context.Context, in *FloatPathRequest) (*httpbody.HttpBody, error) {
	if err := gorilla.ValidateRequest(ctx, in, c.shouldFailFast, c.onValidationErrCallback); err != nil {
		return nil, err
	}
	req, err := c.encoder.FloatPath(ctx, in)
	if err != nil {
		return nil, err
	}
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, err
	}
	out, err := c.decoder.FloatPath(ctx, resp)
	if err != nil {
		return nil, err
	}
	return out, nil
}

type floatPathGorillaRequestEncoder struct {
}

func (c *floatPathGorillaRequestEncoder) FloatPath(ctx context.Context, request *FloatPathRequest) (*http.Request, error) {
	return nil, nil
}

type floatPathGorillaResponseDecoder struct {
}

func (c *floatPathGorillaResponseDecoder) FloatPath(ctx context.Context, response *http.Response) (*httpbody.HttpBody, error) {
	return nil, nil
}

type DoublePathGorillaService interface {
	DoublePath(ctx context.Context, request *DoublePathRequest) (*httpbody.HttpBody, error)
}

func AppendDoublePathGorillaRoute(router *mux.Router, service DoublePathGorillaService, opts ...gorilla.Option) *mux.Router {
	options := gorilla.NewOptions(opts...)
	handler := doublePathGorillaHandler{
		service: service,
		decoder: doublePathGorillaRequestDecoder{
			unmarshalOptions: options.UnmarshalOptions(),
		},
		encoder: doublePathGorillaResponseEncoder{
			marshalOptions:      options.MarshalOptions(),
			unmarshalOptions:    options.UnmarshalOptions(),
			responseTransformer: options.ResponseTransformer(),
		},
		errorEncoder:            gorilla.DefaultEncodeError,
		shouldFailFast:          options.ShouldFailFast(),
		onValidationErrCallback: options.OnValidationErrCallback(),
	}
	router.NewRoute().
		Name("/leo.gorilla.example.path.v1.DoublePath/DoublePath").
		Methods("GET").
		Path("/v1/{double}/{opt_double}/{wrap_double}").
		Handler(gorilla.Chain(handler.DoublePath(), options.Middlewares()...))
	return router
}

type doublePathGorillaHandler struct {
	service                 DoublePathGorillaService
	decoder                 doublePathGorillaRequestDecoder
	encoder                 doublePathGorillaResponseEncoder
	errorEncoder            gorilla.ErrorEncoder
	shouldFailFast          bool
	onValidationErrCallback gorilla.OnValidationErrCallback
}

func (h doublePathGorillaHandler) DoublePath() http.Handler {
	return http.HandlerFunc(func(writer http.ResponseWriter, request *http.Request) {
		ctx := request.Context()
		in, err := h.decoder.DoublePath(ctx, request)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		if err := gorilla.ValidateRequest(ctx, in, h.shouldFailFast, h.onValidationErrCallback); err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		out, err := h.service.DoublePath(ctx, in)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		if err := h.encoder.DoublePath(ctx, writer, out); err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
	})
}

type doublePathGorillaRequestDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder doublePathGorillaRequestDecoder) DoublePath(ctx context.Context, r *http.Request) (*DoublePathRequest, error) {
	req := &DoublePathRequest{}
	ok, err := gorilla.CustomDecodeRequest(ctx, r, req)
	if err != nil {
		return nil, err
	}
	if ok {
		return req, nil
	}
	vars := gorilla.FormFromMap(mux.Vars(r))
	var varErr error
	req.Double, varErr = gorilla.DecodeForm[float64](varErr, vars, "double", gorilla.GetFloat64)
	req.OptDouble, varErr = gorilla.DecodeForm[*float64](varErr, vars, "opt_double", gorilla.GetFloat64Ptr)
	req.WrapDouble, varErr = gorilla.DecodeForm[*wrapperspb.DoubleValue](varErr, vars, "wrap_double", gorilla.GetFloat64Value)
	req.Double, varErr = gorilla.DecodeForm[float64](varErr, vars, "double", gorilla.GetFloat64)
	req.OptDouble, varErr = gorilla.DecodeForm[*float64](varErr, vars, "opt_double", gorilla.GetFloat64Ptr)
	req.WrapDouble, varErr = gorilla.DecodeForm[*wrapperspb.DoubleValue](varErr, vars, "wrap_double", gorilla.GetFloat64Value)
	if varErr != nil {
		return nil, varErr
	}
	return req, nil
}

type doublePathGorillaResponseEncoder struct {
	marshalOptions      protojson.MarshalOptions
	unmarshalOptions    protojson.UnmarshalOptions
	responseTransformer gorilla.ResponseTransformer
}

func (encoder doublePathGorillaResponseEncoder) DoublePath(ctx context.Context, w http.ResponseWriter, resp *httpbody.HttpBody) error {
	return gorilla.EncodeHttpBody(ctx, w, resp)
}

type doublePathGorillaClient struct {
	client                  *http.Client
	encoder                 doublePathGorillaRequestEncoder
	decoder                 doublePathGorillaResponseDecoder
	shouldFailFast          bool
	onValidationErrCallback gorilla.OnValidationErrCallback
}

func (c *doublePathGorillaClient) DoublePath(ctx context.Context, in *DoublePathRequest) (*httpbody.HttpBody, error) {
	if err := gorilla.ValidateRequest(ctx, in, c.shouldFailFast, c.onValidationErrCallback); err != nil {
		return nil, err
	}
	req, err := c.encoder.DoublePath(ctx, in)
	if err != nil {
		return nil, err
	}
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, err
	}
	out, err := c.decoder.DoublePath(ctx, resp)
	if err != nil {
		return nil, err
	}
	return out, nil
}

type doublePathGorillaRequestEncoder struct {
}

func (c *doublePathGorillaRequestEncoder) DoublePath(ctx context.Context, request *DoublePathRequest) (*http.Request, error) {
	return nil, nil
}

type doublePathGorillaResponseDecoder struct {
}

func (c *doublePathGorillaResponseDecoder) DoublePath(ctx context.Context, response *http.Response) (*httpbody.HttpBody, error) {
	return nil, nil
}

type StringPathGorillaService interface {
	StringPath(ctx context.Context, request *StringPathRequest) (*httpbody.HttpBody, error)
}

func AppendStringPathGorillaRoute(router *mux.Router, service StringPathGorillaService, opts ...gorilla.Option) *mux.Router {
	options := gorilla.NewOptions(opts...)
	handler := stringPathGorillaHandler{
		service: service,
		decoder: stringPathGorillaRequestDecoder{
			unmarshalOptions: options.UnmarshalOptions(),
		},
		encoder: stringPathGorillaResponseEncoder{
			marshalOptions:      options.MarshalOptions(),
			unmarshalOptions:    options.UnmarshalOptions(),
			responseTransformer: options.ResponseTransformer(),
		},
		errorEncoder:            gorilla.DefaultEncodeError,
		shouldFailFast:          options.ShouldFailFast(),
		onValidationErrCallback: options.OnValidationErrCallback(),
	}
	router.NewRoute().
		Name("/leo.gorilla.example.path.v1.StringPath/StringPath").
		Methods("GET").
		Path("/v1/{string}/{opt_string}/{wrap_string}").
		Handler(gorilla.Chain(handler.StringPath(), options.Middlewares()...))
	return router
}

type stringPathGorillaHandler struct {
	service                 StringPathGorillaService
	decoder                 stringPathGorillaRequestDecoder
	encoder                 stringPathGorillaResponseEncoder
	errorEncoder            gorilla.ErrorEncoder
	shouldFailFast          bool
	onValidationErrCallback gorilla.OnValidationErrCallback
}

func (h stringPathGorillaHandler) StringPath() http.Handler {
	return http.HandlerFunc(func(writer http.ResponseWriter, request *http.Request) {
		ctx := request.Context()
		in, err := h.decoder.StringPath(ctx, request)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		if err := gorilla.ValidateRequest(ctx, in, h.shouldFailFast, h.onValidationErrCallback); err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		out, err := h.service.StringPath(ctx, in)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		if err := h.encoder.StringPath(ctx, writer, out); err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
	})
}

type stringPathGorillaRequestDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder stringPathGorillaRequestDecoder) StringPath(ctx context.Context, r *http.Request) (*StringPathRequest, error) {
	req := &StringPathRequest{}
	ok, err := gorilla.CustomDecodeRequest(ctx, r, req)
	if err != nil {
		return nil, err
	}
	if ok {
		return req, nil
	}
	vars := gorilla.FormFromMap(mux.Vars(r))
	var varErr error
	req.String_ = vars.Get("string")
	req.OptString = proto.String(vars.Get("opt_string"))
	req.WrapString = wrapperspb.String(vars.Get("wrap_string"))
	req.String_ = vars.Get("string")
	req.OptString = proto.String(vars.Get("opt_string"))
	req.WrapString = wrapperspb.String(vars.Get("wrap_string"))
	if varErr != nil {
		return nil, varErr
	}
	return req, nil
}

type stringPathGorillaResponseEncoder struct {
	marshalOptions      protojson.MarshalOptions
	unmarshalOptions    protojson.UnmarshalOptions
	responseTransformer gorilla.ResponseTransformer
}

func (encoder stringPathGorillaResponseEncoder) StringPath(ctx context.Context, w http.ResponseWriter, resp *httpbody.HttpBody) error {
	return gorilla.EncodeHttpBody(ctx, w, resp)
}

type stringPathGorillaClient struct {
	client                  *http.Client
	encoder                 stringPathGorillaRequestEncoder
	decoder                 stringPathGorillaResponseDecoder
	shouldFailFast          bool
	onValidationErrCallback gorilla.OnValidationErrCallback
}

func (c *stringPathGorillaClient) StringPath(ctx context.Context, in *StringPathRequest) (*httpbody.HttpBody, error) {
	if err := gorilla.ValidateRequest(ctx, in, c.shouldFailFast, c.onValidationErrCallback); err != nil {
		return nil, err
	}
	req, err := c.encoder.StringPath(ctx, in)
	if err != nil {
		return nil, err
	}
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, err
	}
	out, err := c.decoder.StringPath(ctx, resp)
	if err != nil {
		return nil, err
	}
	return out, nil
}

type stringPathGorillaRequestEncoder struct {
}

func (c *stringPathGorillaRequestEncoder) StringPath(ctx context.Context, request *StringPathRequest) (*http.Request, error) {
	return nil, nil
}

type stringPathGorillaResponseDecoder struct {
}

func (c *stringPathGorillaResponseDecoder) StringPath(ctx context.Context, response *http.Response) (*httpbody.HttpBody, error) {
	return nil, nil
}

type EnumPathGorillaService interface {
	EnumPath(ctx context.Context, request *EnumPathRequest) (*httpbody.HttpBody, error)
}

func AppendEnumPathGorillaRoute(router *mux.Router, service EnumPathGorillaService, opts ...gorilla.Option) *mux.Router {
	options := gorilla.NewOptions(opts...)
	handler := enumPathGorillaHandler{
		service: service,
		decoder: enumPathGorillaRequestDecoder{
			unmarshalOptions: options.UnmarshalOptions(),
		},
		encoder: enumPathGorillaResponseEncoder{
			marshalOptions:      options.MarshalOptions(),
			unmarshalOptions:    options.UnmarshalOptions(),
			responseTransformer: options.ResponseTransformer(),
		},
		errorEncoder:            gorilla.DefaultEncodeError,
		shouldFailFast:          options.ShouldFailFast(),
		onValidationErrCallback: options.OnValidationErrCallback(),
	}
	router.NewRoute().
		Name("/leo.gorilla.example.path.v1.EnumPath/EnumPath").
		Methods("GET").
		Path("/v1/{status}/{opt_status}").
		Handler(gorilla.Chain(handler.EnumPath(), options.Middlewares()...))
	return router
}

type enumPathGorillaHandler struct {
	service                 EnumPathGorillaService
	decoder                 enumPathGorillaRequestDecoder
	encoder                 enumPathGorillaResponseEncoder
	errorEncoder            gorilla.ErrorEncoder
	shouldFailFast          bool
	onValidationErrCallback gorilla.OnValidationErrCallback
}

func (h enumPathGorillaHandler) EnumPath() http.Handler {
	return http.HandlerFunc(func(writer http.ResponseWriter, request *http.Request) {
		ctx := request.Context()
		in, err := h.decoder.EnumPath(ctx, request)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		if err := gorilla.ValidateRequest(ctx, in, h.shouldFailFast, h.onValidationErrCallback); err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		out, err := h.service.EnumPath(ctx, in)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		if err := h.encoder.EnumPath(ctx, writer, out); err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
	})
}

type enumPathGorillaRequestDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder enumPathGorillaRequestDecoder) EnumPath(ctx context.Context, r *http.Request) (*EnumPathRequest, error) {
	req := &EnumPathRequest{}
	ok, err := gorilla.CustomDecodeRequest(ctx, r, req)
	if err != nil {
		return nil, err
	}
	if ok {
		return req, nil
	}
	vars := gorilla.FormFromMap(mux.Vars(r))
	var varErr error
	req.Status, varErr = gorilla.DecodeForm[EnumPathRequest_Status](varErr, vars, "status", gorilla.GetInt[EnumPathRequest_Status])
	req.OptStatus, varErr = gorilla.DecodeForm[*EnumPathRequest_Status](varErr, vars, "opt_status", gorilla.GetIntPtr[EnumPathRequest_Status])
	req.Status, varErr = gorilla.DecodeForm[EnumPathRequest_Status](varErr, vars, "status", gorilla.GetInt[EnumPathRequest_Status])
	req.OptStatus, varErr = gorilla.DecodeForm[*EnumPathRequest_Status](varErr, vars, "opt_status", gorilla.GetIntPtr[EnumPathRequest_Status])
	if varErr != nil {
		return nil, varErr
	}
	return req, nil
}

type enumPathGorillaResponseEncoder struct {
	marshalOptions      protojson.MarshalOptions
	unmarshalOptions    protojson.UnmarshalOptions
	responseTransformer gorilla.ResponseTransformer
}

func (encoder enumPathGorillaResponseEncoder) EnumPath(ctx context.Context, w http.ResponseWriter, resp *httpbody.HttpBody) error {
	return gorilla.EncodeHttpBody(ctx, w, resp)
}

type enumPathGorillaClient struct {
	client                  *http.Client
	encoder                 enumPathGorillaRequestEncoder
	decoder                 enumPathGorillaResponseDecoder
	shouldFailFast          bool
	onValidationErrCallback gorilla.OnValidationErrCallback
}

func (c *enumPathGorillaClient) EnumPath(ctx context.Context, in *EnumPathRequest) (*httpbody.HttpBody, error) {
	if err := gorilla.ValidateRequest(ctx, in, c.shouldFailFast, c.onValidationErrCallback); err != nil {
		return nil, err
	}
	req, err := c.encoder.EnumPath(ctx, in)
	if err != nil {
		return nil, err
	}
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, err
	}
	out, err := c.decoder.EnumPath(ctx, resp)
	if err != nil {
		return nil, err
	}
	return out, nil
}

type enumPathGorillaRequestEncoder struct {
}

func (c *enumPathGorillaRequestEncoder) EnumPath(ctx context.Context, request *EnumPathRequest) (*http.Request, error) {
	return nil, nil
}

type enumPathGorillaResponseDecoder struct {
}

func (c *enumPathGorillaResponseDecoder) EnumPath(ctx context.Context, response *http.Response) (*httpbody.HttpBody, error) {
	return nil, nil
}
