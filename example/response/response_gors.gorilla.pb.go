// Code generated by protoc-gen-gors-gorilla. DO NOT EDIT.

package response

import (
	context "context"
	v2 "github.com/go-leo/gors/v2"
	errorx "github.com/go-leo/gox/errorx"
	mux "github.com/gorilla/mux"
	httpbody "google.golang.org/genproto/googleapis/api/httpbody"
	protojson "google.golang.org/protobuf/encoding/protojson"
	anypb "google.golang.org/protobuf/types/known/anypb"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
	structpb "google.golang.org/protobuf/types/known/structpb"
	http "net/http"
)

type ResponseGorillaService interface {
	OmittedResponse(ctx context.Context, request *emptypb.Empty) (*UserResponse, error)
	StarResponse(ctx context.Context, request *emptypb.Empty) (*UserResponse, error)
	NamedResponse(ctx context.Context, request *emptypb.Empty) (*UserResponse, error)
	HttpBodyResponse(ctx context.Context, request *emptypb.Empty) (*httpbody.HttpBody, error)
	HttpBodyNamedResponse(ctx context.Context, request *emptypb.Empty) (*HttpBody, error)
}

func AppendResponseGorillaRoute(router *mux.Router, svc ResponseGorillaService) *mux.Router {
	handler := &ResponseGorillaHandler{
		svc: svc,
		decoder: ResponseGorillaRequestDecoder{
			unmarshalOptions: protojson.UnmarshalOptions{},
		},
		encoder: ResponseGorillaResponseEncoder{
			marshalOptions:   protojson.MarshalOptions{},
			unmarshalOptions: protojson.UnmarshalOptions{},
		},
		errorEncoder: v2.DefaultErrorEncoder,
	}
	router.NewRoute().Name("/leo.gors.response.v1.Response/OmittedResponse").
		Methods("POST").
		Path("/v1/omitted/response").
		Handler(handler.OmittedResponse())
	router.NewRoute().Name("/leo.gors.response.v1.Response/StarResponse").
		Methods("POST").
		Path("/v1/star/response").
		Handler(handler.StarResponse())
	router.NewRoute().Name("/leo.gors.response.v1.Response/NamedResponse").
		Methods("POST").
		Path("/v1/named/response").
		Handler(handler.NamedResponse())
	router.NewRoute().Name("/leo.gors.response.v1.Response/HttpBodyResponse").
		Methods("PUT").
		Path("/v1/http/body/omitted/response").
		Handler(handler.HttpBodyResponse())
	router.NewRoute().Name("/leo.gors.response.v1.Response/HttpBodyNamedResponse").
		Methods("PUT").
		Path("/v1/http/body/named/response").
		Handler(handler.HttpBodyNamedResponse())
	return router
}

type ResponseGorillaHandler struct {
	svc          ResponseGorillaService
	decoder      ResponseGorillaRequestDecoder
	encoder      ResponseGorillaResponseEncoder
	errorEncoder v2.ErrorEncoder
}

func (h *ResponseGorillaHandler) OmittedResponse() http.Handler {
	return http.HandlerFunc(func(writer http.ResponseWriter, request *http.Request) {
		ctx := request.Context()
		in, err := h.decoder.OmittedResponse(ctx, request)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		out, err := h.svc.OmittedResponse(ctx, in)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		if err := h.encoder.OmittedResponse(ctx, writer, out); err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
	})
}

func (h *ResponseGorillaHandler) StarResponse() http.Handler {
	return http.HandlerFunc(func(writer http.ResponseWriter, request *http.Request) {
		ctx := request.Context()
		in, err := h.decoder.StarResponse(ctx, request)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		out, err := h.svc.StarResponse(ctx, in)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		if err := h.encoder.StarResponse(ctx, writer, out); err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
	})
}

func (h *ResponseGorillaHandler) NamedResponse() http.Handler {
	return http.HandlerFunc(func(writer http.ResponseWriter, request *http.Request) {
		ctx := request.Context()
		in, err := h.decoder.NamedResponse(ctx, request)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		out, err := h.svc.NamedResponse(ctx, in)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		if err := h.encoder.NamedResponse(ctx, writer, out); err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
	})
}

func (h *ResponseGorillaHandler) HttpBodyResponse() http.Handler {
	return http.HandlerFunc(func(writer http.ResponseWriter, request *http.Request) {
		ctx := request.Context()
		in, err := h.decoder.HttpBodyResponse(ctx, request)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		out, err := h.svc.HttpBodyResponse(ctx, in)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		if err := h.encoder.HttpBodyResponse(ctx, writer, out); err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
	})
}

func (h *ResponseGorillaHandler) HttpBodyNamedResponse() http.Handler {
	return http.HandlerFunc(func(writer http.ResponseWriter, request *http.Request) {
		ctx := request.Context()
		in, err := h.decoder.HttpBodyNamedResponse(ctx, request)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		out, err := h.svc.HttpBodyNamedResponse(ctx, in)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		if err := h.encoder.HttpBodyNamedResponse(ctx, writer, out); err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
	})
}

type ResponseGorillaRequestDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder ResponseGorillaRequestDecoder) OmittedResponse(ctx context.Context, r *http.Request) (*emptypb.Empty, error) {
	req := &emptypb.Empty{}
	return req, nil
}
func (decoder ResponseGorillaRequestDecoder) StarResponse(ctx context.Context, r *http.Request) (*emptypb.Empty, error) {
	req := &emptypb.Empty{}
	return req, nil
}
func (decoder ResponseGorillaRequestDecoder) NamedResponse(ctx context.Context, r *http.Request) (*emptypb.Empty, error) {
	req := &emptypb.Empty{}
	return req, nil
}
func (decoder ResponseGorillaRequestDecoder) HttpBodyResponse(ctx context.Context, r *http.Request) (*emptypb.Empty, error) {
	req := &emptypb.Empty{}
	return req, nil
}
func (decoder ResponseGorillaRequestDecoder) HttpBodyNamedResponse(ctx context.Context, r *http.Request) (*emptypb.Empty, error) {
	req := &emptypb.Empty{}
	return req, nil
}

type ResponseGorillaResponseEncoder struct {
	marshalOptions   protojson.MarshalOptions
	unmarshalOptions protojson.UnmarshalOptions
}

func (encoder ResponseGorillaResponseEncoder) OmittedResponse(ctx context.Context, w http.ResponseWriter, resp *UserResponse) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(http.StatusOK)
	data, err := encoder.marshalOptions.Marshal(resp)
	if err != nil {
		return err
	}
	if _, err := w.Write(data); err != nil {
		return err
	}
	return nil
}
func (encoder ResponseGorillaResponseEncoder) StarResponse(ctx context.Context, w http.ResponseWriter, resp *UserResponse) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(http.StatusOK)
	data, err := encoder.marshalOptions.Marshal(resp)
	if err != nil {
		return err
	}
	if _, err := w.Write(data); err != nil {
		return err
	}
	return nil
}
func (encoder ResponseGorillaResponseEncoder) NamedResponse(ctx context.Context, w http.ResponseWriter, resp *UserResponse) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(http.StatusOK)
	data, err := encoder.marshalOptions.Marshal(resp.GetUser())
	if err != nil {
		return err
	}
	if _, err := w.Write(data); err != nil {
		return err
	}
	return nil
}
func (encoder ResponseGorillaResponseEncoder) HttpBodyResponse(ctx context.Context, w http.ResponseWriter, resp *httpbody.HttpBody) error {
	w.Header().Set("Content-Type", resp.GetContentType())
	for _, src := range resp.GetExtensions() {
		dst, err := anypb.UnmarshalNew(src, encoder.unmarshalOptions)
		if err != nil {
			return err
		}
		metadata, ok := dst.(*structpb.Struct)
		if !ok {
			continue
		}
		for key, value := range metadata.GetFields() {
			w.Header().Add(key, string(errorx.Ignore(encoder.marshalOptions(value))))
		}
	}
	w.WriteHeader(http.StatusOK)
	if _, err := w.Write(resp.GetData()); err != nil {
		return err
	}
	return nil
}
func (encoder ResponseGorillaResponseEncoder) HttpBodyNamedResponse(ctx context.Context, w http.ResponseWriter, resp *HttpBody) error {
	w.Header().Set("Content-Type", resp.GetBody().GetContentType())
	for _, src := range resp.GetBody().GetExtensions() {
		dst, err := anypb.UnmarshalNew(src, encoder.unmarshalOptions)
		if err != nil {
			return err
		}
		metadata, ok := dst.(*structpb.Struct)
		if !ok {
			continue
		}
		for key, value := range metadata.GetFields() {
			w.Header().Add(key, string(errorx.Ignore(encoder.marshalOptions(value))))
		}
	}
	w.WriteHeader(http.StatusOK)
	if _, err := w.Write(resp.GetBody().GetData()); err != nil {
		return err
	}
	return nil
}
