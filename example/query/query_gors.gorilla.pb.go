// Code generated by protoc-gen-gors-gorilla. DO NOT EDIT.

package query

import (
	context "context"
	v2 "github.com/go-leo/gors/v2"
	urlx "github.com/go-leo/gox/netx/urlx"
	mux "github.com/gorilla/mux"
	protojson "google.golang.org/protobuf/encoding/protojson"
	proto "google.golang.org/protobuf/proto"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
	wrapperspb "google.golang.org/protobuf/types/known/wrapperspb"
	http "net/http"
)

type BoolQueryGorillaService interface {
	BoolQuery(ctx context.Context, request *BoolQueryRequest) (*emptypb.Empty, error)
}

func AppendBoolQueryGorillaRoute(router *mux.Router, service BoolQueryGorillaService, opts ...v2.Option) *mux.Router {
	options := v2.NewOptions(opts...)
	handler := boolQueryGorillaHandler{
		service: service,
		decoder: boolQueryGorillaRequestDecoder{
			unmarshalOptions: options.UnmarshalOptions(),
		},
		encoder: boolQueryGorillaResponseEncoder{
			marshalOptions:      options.MarshalOptions(),
			unmarshalOptions:    options.UnmarshalOptions(),
			responseTransformer: options.ResponseTransformer(),
		},
		errorEncoder: v2.DefaultErrorEncoder,
	}
	router.NewRoute().
		Name("/leo.gors.query.v1.BoolQuery/BoolQuery").
		Methods("GET").
		Path("/v1/bool").
		Handler(handler.BoolQuery())
	return router
}

type boolQueryGorillaHandler struct {
	service      BoolQueryGorillaService
	decoder      boolQueryGorillaRequestDecoder
	encoder      boolQueryGorillaResponseEncoder
	errorEncoder v2.ErrorEncoder
}

func (h boolQueryGorillaHandler) BoolQuery() http.Handler {
	return http.HandlerFunc(func(writer http.ResponseWriter, request *http.Request) {
		ctx := request.Context()
		in, err := h.decoder.BoolQuery(ctx, request)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		out, err := h.service.BoolQuery(ctx, in)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		if err := h.encoder.BoolQuery(ctx, writer, out); err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
	})
}

type boolQueryGorillaRequestDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder boolQueryGorillaRequestDecoder) BoolQuery(ctx context.Context, r *http.Request) (*BoolQueryRequest, error) {
	req := &BoolQueryRequest{}
	queries := r.URL.Query()
	var queryErr error
	req.Bool, queryErr = v2.FormDecoder[bool](queryErr, queries, "bool", urlx.GetBool)
	req.OptBool, queryErr = v2.FormDecoder[*bool](queryErr, queries, "opt_bool", urlx.GetBoolPtr)
	req.WrapBool, queryErr = v2.FormDecoder[*wrapperspb.BoolValue](queryErr, queries, "wrap_bool", urlx.GetBoolValue)
	if queryErr != nil {
		return nil, queryErr
	}
	return req, nil
}

type boolQueryGorillaResponseEncoder struct {
	marshalOptions      protojson.MarshalOptions
	unmarshalOptions    protojson.UnmarshalOptions
	responseTransformer v2.ResponseTransformer
}

func (encoder boolQueryGorillaResponseEncoder) BoolQuery(ctx context.Context, w http.ResponseWriter, resp *emptypb.Empty) error {
	return v2.ResponseEncoder(ctx, w, encoder.responseTransformer(ctx, resp), encoder.marshalOptions)
}

type Int32QueryGorillaService interface {
	Int32Query(ctx context.Context, request *Int32QueryRequest) (*emptypb.Empty, error)
}

func AppendInt32QueryGorillaRoute(router *mux.Router, service Int32QueryGorillaService, opts ...v2.Option) *mux.Router {
	options := v2.NewOptions(opts...)
	handler := int32QueryGorillaHandler{
		service: service,
		decoder: int32QueryGorillaRequestDecoder{
			unmarshalOptions: options.UnmarshalOptions(),
		},
		encoder: int32QueryGorillaResponseEncoder{
			marshalOptions:      options.MarshalOptions(),
			unmarshalOptions:    options.UnmarshalOptions(),
			responseTransformer: options.ResponseTransformer(),
		},
		errorEncoder: v2.DefaultErrorEncoder,
	}
	router.NewRoute().
		Name("/leo.gors.query.v1.Int32Query/Int32Query").
		Methods("GET").
		Path("/v1/int32").
		Handler(handler.Int32Query())
	return router
}

type int32QueryGorillaHandler struct {
	service      Int32QueryGorillaService
	decoder      int32QueryGorillaRequestDecoder
	encoder      int32QueryGorillaResponseEncoder
	errorEncoder v2.ErrorEncoder
}

func (h int32QueryGorillaHandler) Int32Query() http.Handler {
	return http.HandlerFunc(func(writer http.ResponseWriter, request *http.Request) {
		ctx := request.Context()
		in, err := h.decoder.Int32Query(ctx, request)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		out, err := h.service.Int32Query(ctx, in)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		if err := h.encoder.Int32Query(ctx, writer, out); err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
	})
}

type int32QueryGorillaRequestDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder int32QueryGorillaRequestDecoder) Int32Query(ctx context.Context, r *http.Request) (*Int32QueryRequest, error) {
	req := &Int32QueryRequest{}
	queries := r.URL.Query()
	var queryErr error
	req.Int32, queryErr = v2.FormDecoder[int32](queryErr, queries, "int32", urlx.GetInt)
	req.Sint32, queryErr = v2.FormDecoder[int32](queryErr, queries, "sint32", urlx.GetInt)
	req.Sfixed32, queryErr = v2.FormDecoder[int32](queryErr, queries, "sfixed32", urlx.GetInt)
	req.OptInt32, queryErr = v2.FormDecoder[*int32](queryErr, queries, "opt_int32", urlx.GetIntPtr)
	req.OptSint32, queryErr = v2.FormDecoder[*int32](queryErr, queries, "opt_sint32", urlx.GetIntPtr)
	req.OptSfixed32, queryErr = v2.FormDecoder[*int32](queryErr, queries, "opt_sfixed32", urlx.GetIntPtr)
	req.WrapInt32, queryErr = v2.FormDecoder[*wrapperspb.Int32Value](queryErr, queries, "wrap_int32", urlx.GetInt32Value)
	if queryErr != nil {
		return nil, queryErr
	}
	return req, nil
}

type int32QueryGorillaResponseEncoder struct {
	marshalOptions      protojson.MarshalOptions
	unmarshalOptions    protojson.UnmarshalOptions
	responseTransformer v2.ResponseTransformer
}

func (encoder int32QueryGorillaResponseEncoder) Int32Query(ctx context.Context, w http.ResponseWriter, resp *emptypb.Empty) error {
	return v2.ResponseEncoder(ctx, w, encoder.responseTransformer(ctx, resp), encoder.marshalOptions)
}

type Int64QueryGorillaService interface {
	Int64Query(ctx context.Context, request *Int64QueryRequest) (*emptypb.Empty, error)
}

func AppendInt64QueryGorillaRoute(router *mux.Router, service Int64QueryGorillaService, opts ...v2.Option) *mux.Router {
	options := v2.NewOptions(opts...)
	handler := int64QueryGorillaHandler{
		service: service,
		decoder: int64QueryGorillaRequestDecoder{
			unmarshalOptions: options.UnmarshalOptions(),
		},
		encoder: int64QueryGorillaResponseEncoder{
			marshalOptions:      options.MarshalOptions(),
			unmarshalOptions:    options.UnmarshalOptions(),
			responseTransformer: options.ResponseTransformer(),
		},
		errorEncoder: v2.DefaultErrorEncoder,
	}
	router.NewRoute().
		Name("/leo.gors.query.v1.Int64Query/Int64Query").
		Methods("GET").
		Path("/v1/int64").
		Handler(handler.Int64Query())
	return router
}

type int64QueryGorillaHandler struct {
	service      Int64QueryGorillaService
	decoder      int64QueryGorillaRequestDecoder
	encoder      int64QueryGorillaResponseEncoder
	errorEncoder v2.ErrorEncoder
}

func (h int64QueryGorillaHandler) Int64Query() http.Handler {
	return http.HandlerFunc(func(writer http.ResponseWriter, request *http.Request) {
		ctx := request.Context()
		in, err := h.decoder.Int64Query(ctx, request)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		out, err := h.service.Int64Query(ctx, in)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		if err := h.encoder.Int64Query(ctx, writer, out); err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
	})
}

type int64QueryGorillaRequestDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder int64QueryGorillaRequestDecoder) Int64Query(ctx context.Context, r *http.Request) (*Int64QueryRequest, error) {
	req := &Int64QueryRequest{}
	queries := r.URL.Query()
	var queryErr error
	req.Int64, queryErr = v2.FormDecoder[int64](queryErr, queries, "int64", urlx.GetInt)
	req.Sint64, queryErr = v2.FormDecoder[int64](queryErr, queries, "sint64", urlx.GetInt)
	req.Sfixed64, queryErr = v2.FormDecoder[int64](queryErr, queries, "sfixed64", urlx.GetInt)
	req.OptInt64, queryErr = v2.FormDecoder[*int64](queryErr, queries, "opt_int64", urlx.GetIntPtr)
	req.OptSint64, queryErr = v2.FormDecoder[*int64](queryErr, queries, "opt_sint64", urlx.GetIntPtr)
	req.OptSfixed64, queryErr = v2.FormDecoder[*int64](queryErr, queries, "opt_sfixed64", urlx.GetIntPtr)
	req.WrapInt64, queryErr = v2.FormDecoder[*wrapperspb.Int64Value](queryErr, queries, "wrap_int64", urlx.GetInt64Value)
	if queryErr != nil {
		return nil, queryErr
	}
	return req, nil
}

type int64QueryGorillaResponseEncoder struct {
	marshalOptions      protojson.MarshalOptions
	unmarshalOptions    protojson.UnmarshalOptions
	responseTransformer v2.ResponseTransformer
}

func (encoder int64QueryGorillaResponseEncoder) Int64Query(ctx context.Context, w http.ResponseWriter, resp *emptypb.Empty) error {
	return v2.ResponseEncoder(ctx, w, encoder.responseTransformer(ctx, resp), encoder.marshalOptions)
}

type Uint32QueryGorillaService interface {
	Uint32Query(ctx context.Context, request *Uint32QueryRequest) (*emptypb.Empty, error)
}

func AppendUint32QueryGorillaRoute(router *mux.Router, service Uint32QueryGorillaService, opts ...v2.Option) *mux.Router {
	options := v2.NewOptions(opts...)
	handler := uint32QueryGorillaHandler{
		service: service,
		decoder: uint32QueryGorillaRequestDecoder{
			unmarshalOptions: options.UnmarshalOptions(),
		},
		encoder: uint32QueryGorillaResponseEncoder{
			marshalOptions:      options.MarshalOptions(),
			unmarshalOptions:    options.UnmarshalOptions(),
			responseTransformer: options.ResponseTransformer(),
		},
		errorEncoder: v2.DefaultErrorEncoder,
	}
	router.NewRoute().
		Name("/leo.gors.query.v1.Uint32Query/Uint32Query").
		Methods("GET").
		Path("/v1/uint32").
		Handler(handler.Uint32Query())
	return router
}

type uint32QueryGorillaHandler struct {
	service      Uint32QueryGorillaService
	decoder      uint32QueryGorillaRequestDecoder
	encoder      uint32QueryGorillaResponseEncoder
	errorEncoder v2.ErrorEncoder
}

func (h uint32QueryGorillaHandler) Uint32Query() http.Handler {
	return http.HandlerFunc(func(writer http.ResponseWriter, request *http.Request) {
		ctx := request.Context()
		in, err := h.decoder.Uint32Query(ctx, request)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		out, err := h.service.Uint32Query(ctx, in)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		if err := h.encoder.Uint32Query(ctx, writer, out); err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
	})
}

type uint32QueryGorillaRequestDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder uint32QueryGorillaRequestDecoder) Uint32Query(ctx context.Context, r *http.Request) (*Uint32QueryRequest, error) {
	req := &Uint32QueryRequest{}
	queries := r.URL.Query()
	var queryErr error
	req.Uint32, queryErr = v2.FormDecoder[uint32](queryErr, queries, "uint32", urlx.GetUint)
	req.Fixed32, queryErr = v2.FormDecoder[uint32](queryErr, queries, "fixed32", urlx.GetUint)
	req.OptUint32, queryErr = v2.FormDecoder[*uint32](queryErr, queries, "opt_uint32", urlx.GetUintPtr)
	req.OptFixed32, queryErr = v2.FormDecoder[*uint32](queryErr, queries, "opt_fixed32", urlx.GetUintPtr)
	req.WrapUint32, queryErr = v2.FormDecoder[*wrapperspb.UInt32Value](queryErr, queries, "wrap_uint32", urlx.GetUint32Value)
	if queryErr != nil {
		return nil, queryErr
	}
	return req, nil
}

type uint32QueryGorillaResponseEncoder struct {
	marshalOptions      protojson.MarshalOptions
	unmarshalOptions    protojson.UnmarshalOptions
	responseTransformer v2.ResponseTransformer
}

func (encoder uint32QueryGorillaResponseEncoder) Uint32Query(ctx context.Context, w http.ResponseWriter, resp *emptypb.Empty) error {
	return v2.ResponseEncoder(ctx, w, encoder.responseTransformer(ctx, resp), encoder.marshalOptions)
}

type Uint64QueryGorillaService interface {
	Uint64Query(ctx context.Context, request *Uint64QueryRequest) (*emptypb.Empty, error)
}

func AppendUint64QueryGorillaRoute(router *mux.Router, service Uint64QueryGorillaService, opts ...v2.Option) *mux.Router {
	options := v2.NewOptions(opts...)
	handler := uint64QueryGorillaHandler{
		service: service,
		decoder: uint64QueryGorillaRequestDecoder{
			unmarshalOptions: options.UnmarshalOptions(),
		},
		encoder: uint64QueryGorillaResponseEncoder{
			marshalOptions:      options.MarshalOptions(),
			unmarshalOptions:    options.UnmarshalOptions(),
			responseTransformer: options.ResponseTransformer(),
		},
		errorEncoder: v2.DefaultErrorEncoder,
	}
	router.NewRoute().
		Name("/leo.gors.query.v1.Uint64Query/Uint64Query").
		Methods("GET").
		Path("/v1/uint64").
		Handler(handler.Uint64Query())
	return router
}

type uint64QueryGorillaHandler struct {
	service      Uint64QueryGorillaService
	decoder      uint64QueryGorillaRequestDecoder
	encoder      uint64QueryGorillaResponseEncoder
	errorEncoder v2.ErrorEncoder
}

func (h uint64QueryGorillaHandler) Uint64Query() http.Handler {
	return http.HandlerFunc(func(writer http.ResponseWriter, request *http.Request) {
		ctx := request.Context()
		in, err := h.decoder.Uint64Query(ctx, request)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		out, err := h.service.Uint64Query(ctx, in)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		if err := h.encoder.Uint64Query(ctx, writer, out); err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
	})
}

type uint64QueryGorillaRequestDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder uint64QueryGorillaRequestDecoder) Uint64Query(ctx context.Context, r *http.Request) (*Uint64QueryRequest, error) {
	req := &Uint64QueryRequest{}
	queries := r.URL.Query()
	var queryErr error
	req.Uint64, queryErr = v2.FormDecoder[uint64](queryErr, queries, "uint64", urlx.GetUint)
	req.Fixed64, queryErr = v2.FormDecoder[uint64](queryErr, queries, "fixed64", urlx.GetUint)
	req.OptUint64, queryErr = v2.FormDecoder[*uint64](queryErr, queries, "opt_uint64", urlx.GetUintPtr)
	req.OptFixed64, queryErr = v2.FormDecoder[*uint64](queryErr, queries, "opt_fixed64", urlx.GetUintPtr)
	req.WrapUint64, queryErr = v2.FormDecoder[*wrapperspb.UInt64Value](queryErr, queries, "wrap_uint64", urlx.GetUint64Value)
	if queryErr != nil {
		return nil, queryErr
	}
	return req, nil
}

type uint64QueryGorillaResponseEncoder struct {
	marshalOptions      protojson.MarshalOptions
	unmarshalOptions    protojson.UnmarshalOptions
	responseTransformer v2.ResponseTransformer
}

func (encoder uint64QueryGorillaResponseEncoder) Uint64Query(ctx context.Context, w http.ResponseWriter, resp *emptypb.Empty) error {
	return v2.ResponseEncoder(ctx, w, encoder.responseTransformer(ctx, resp), encoder.marshalOptions)
}

type FloatQueryGorillaService interface {
	FloatQuery(ctx context.Context, request *FloatQueryRequest) (*emptypb.Empty, error)
}

func AppendFloatQueryGorillaRoute(router *mux.Router, service FloatQueryGorillaService, opts ...v2.Option) *mux.Router {
	options := v2.NewOptions(opts...)
	handler := floatQueryGorillaHandler{
		service: service,
		decoder: floatQueryGorillaRequestDecoder{
			unmarshalOptions: options.UnmarshalOptions(),
		},
		encoder: floatQueryGorillaResponseEncoder{
			marshalOptions:      options.MarshalOptions(),
			unmarshalOptions:    options.UnmarshalOptions(),
			responseTransformer: options.ResponseTransformer(),
		},
		errorEncoder: v2.DefaultErrorEncoder,
	}
	router.NewRoute().
		Name("/leo.gors.query.v1.FloatQuery/FloatQuery").
		Methods("GET").
		Path("/v1/float").
		Handler(handler.FloatQuery())
	return router
}

type floatQueryGorillaHandler struct {
	service      FloatQueryGorillaService
	decoder      floatQueryGorillaRequestDecoder
	encoder      floatQueryGorillaResponseEncoder
	errorEncoder v2.ErrorEncoder
}

func (h floatQueryGorillaHandler) FloatQuery() http.Handler {
	return http.HandlerFunc(func(writer http.ResponseWriter, request *http.Request) {
		ctx := request.Context()
		in, err := h.decoder.FloatQuery(ctx, request)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		out, err := h.service.FloatQuery(ctx, in)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		if err := h.encoder.FloatQuery(ctx, writer, out); err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
	})
}

type floatQueryGorillaRequestDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder floatQueryGorillaRequestDecoder) FloatQuery(ctx context.Context, r *http.Request) (*FloatQueryRequest, error) {
	req := &FloatQueryRequest{}
	queries := r.URL.Query()
	var queryErr error
	req.Float, queryErr = v2.FormDecoder[float32](queryErr, queries, "float", urlx.GetFloat)
	req.OptFloat, queryErr = v2.FormDecoder[*float32](queryErr, queries, "opt_float", urlx.GetFloatPtr)
	req.WrapFloat, queryErr = v2.FormDecoder[*wrapperspb.FloatValue](queryErr, queries, "wrap_float", urlx.GetFloat32Value)
	if queryErr != nil {
		return nil, queryErr
	}
	return req, nil
}

type floatQueryGorillaResponseEncoder struct {
	marshalOptions      protojson.MarshalOptions
	unmarshalOptions    protojson.UnmarshalOptions
	responseTransformer v2.ResponseTransformer
}

func (encoder floatQueryGorillaResponseEncoder) FloatQuery(ctx context.Context, w http.ResponseWriter, resp *emptypb.Empty) error {
	return v2.ResponseEncoder(ctx, w, encoder.responseTransformer(ctx, resp), encoder.marshalOptions)
}

type DoubleQueryGorillaService interface {
	DoubleQuery(ctx context.Context, request *DoubleQueryRequest) (*emptypb.Empty, error)
}

func AppendDoubleQueryGorillaRoute(router *mux.Router, service DoubleQueryGorillaService, opts ...v2.Option) *mux.Router {
	options := v2.NewOptions(opts...)
	handler := doubleQueryGorillaHandler{
		service: service,
		decoder: doubleQueryGorillaRequestDecoder{
			unmarshalOptions: options.UnmarshalOptions(),
		},
		encoder: doubleQueryGorillaResponseEncoder{
			marshalOptions:      options.MarshalOptions(),
			unmarshalOptions:    options.UnmarshalOptions(),
			responseTransformer: options.ResponseTransformer(),
		},
		errorEncoder: v2.DefaultErrorEncoder,
	}
	router.NewRoute().
		Name("/leo.gors.query.v1.DoubleQuery/DoubleQuery").
		Methods("GET").
		Path("/v1/double").
		Handler(handler.DoubleQuery())
	return router
}

type doubleQueryGorillaHandler struct {
	service      DoubleQueryGorillaService
	decoder      doubleQueryGorillaRequestDecoder
	encoder      doubleQueryGorillaResponseEncoder
	errorEncoder v2.ErrorEncoder
}

func (h doubleQueryGorillaHandler) DoubleQuery() http.Handler {
	return http.HandlerFunc(func(writer http.ResponseWriter, request *http.Request) {
		ctx := request.Context()
		in, err := h.decoder.DoubleQuery(ctx, request)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		out, err := h.service.DoubleQuery(ctx, in)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		if err := h.encoder.DoubleQuery(ctx, writer, out); err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
	})
}

type doubleQueryGorillaRequestDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder doubleQueryGorillaRequestDecoder) DoubleQuery(ctx context.Context, r *http.Request) (*DoubleQueryRequest, error) {
	req := &DoubleQueryRequest{}
	queries := r.URL.Query()
	var queryErr error
	req.Double, queryErr = v2.FormDecoder[float64](queryErr, queries, "double", urlx.GetFloat)
	req.OptDouble, queryErr = v2.FormDecoder[*float64](queryErr, queries, "opt_double", urlx.GetFloatPtr)
	req.WrapDouble, queryErr = v2.FormDecoder[*wrapperspb.DoubleValue](queryErr, queries, "wrap_double", urlx.GetFloat64Value)
	if queryErr != nil {
		return nil, queryErr
	}
	return req, nil
}

type doubleQueryGorillaResponseEncoder struct {
	marshalOptions      protojson.MarshalOptions
	unmarshalOptions    protojson.UnmarshalOptions
	responseTransformer v2.ResponseTransformer
}

func (encoder doubleQueryGorillaResponseEncoder) DoubleQuery(ctx context.Context, w http.ResponseWriter, resp *emptypb.Empty) error {
	return v2.ResponseEncoder(ctx, w, encoder.responseTransformer(ctx, resp), encoder.marshalOptions)
}

type StringQueryGorillaService interface {
	StringQuery(ctx context.Context, request *StringQueryRequest) (*emptypb.Empty, error)
}

func AppendStringQueryGorillaRoute(router *mux.Router, service StringQueryGorillaService, opts ...v2.Option) *mux.Router {
	options := v2.NewOptions(opts...)
	handler := stringQueryGorillaHandler{
		service: service,
		decoder: stringQueryGorillaRequestDecoder{
			unmarshalOptions: options.UnmarshalOptions(),
		},
		encoder: stringQueryGorillaResponseEncoder{
			marshalOptions:      options.MarshalOptions(),
			unmarshalOptions:    options.UnmarshalOptions(),
			responseTransformer: options.ResponseTransformer(),
		},
		errorEncoder: v2.DefaultErrorEncoder,
	}
	router.NewRoute().
		Name("/leo.gors.query.v1.StringQuery/StringQuery").
		Methods("GET").
		Path("/v1/string").
		Handler(handler.StringQuery())
	return router
}

type stringQueryGorillaHandler struct {
	service      StringQueryGorillaService
	decoder      stringQueryGorillaRequestDecoder
	encoder      stringQueryGorillaResponseEncoder
	errorEncoder v2.ErrorEncoder
}

func (h stringQueryGorillaHandler) StringQuery() http.Handler {
	return http.HandlerFunc(func(writer http.ResponseWriter, request *http.Request) {
		ctx := request.Context()
		in, err := h.decoder.StringQuery(ctx, request)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		out, err := h.service.StringQuery(ctx, in)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		if err := h.encoder.StringQuery(ctx, writer, out); err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
	})
}

type stringQueryGorillaRequestDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder stringQueryGorillaRequestDecoder) StringQuery(ctx context.Context, r *http.Request) (*StringQueryRequest, error) {
	req := &StringQueryRequest{}
	queries := r.URL.Query()
	var queryErr error
	req.String_ = queries.Get("string")
	req.OptString = proto.String(queries.Get("opt_string"))
	req.WrapString = wrapperspb.String(queries.Get("wrap_string"))
	if queryErr != nil {
		return nil, queryErr
	}
	return req, nil
}

type stringQueryGorillaResponseEncoder struct {
	marshalOptions      protojson.MarshalOptions
	unmarshalOptions    protojson.UnmarshalOptions
	responseTransformer v2.ResponseTransformer
}

func (encoder stringQueryGorillaResponseEncoder) StringQuery(ctx context.Context, w http.ResponseWriter, resp *emptypb.Empty) error {
	return v2.ResponseEncoder(ctx, w, encoder.responseTransformer(ctx, resp), encoder.marshalOptions)
}

type EnumQueryGorillaService interface {
	EnumQuery(ctx context.Context, request *EnumQueryRequest) (*emptypb.Empty, error)
}

func AppendEnumQueryGorillaRoute(router *mux.Router, service EnumQueryGorillaService, opts ...v2.Option) *mux.Router {
	options := v2.NewOptions(opts...)
	handler := enumQueryGorillaHandler{
		service: service,
		decoder: enumQueryGorillaRequestDecoder{
			unmarshalOptions: options.UnmarshalOptions(),
		},
		encoder: enumQueryGorillaResponseEncoder{
			marshalOptions:      options.MarshalOptions(),
			unmarshalOptions:    options.UnmarshalOptions(),
			responseTransformer: options.ResponseTransformer(),
		},
		errorEncoder: v2.DefaultErrorEncoder,
	}
	router.NewRoute().
		Name("/leo.gors.query.v1.EnumQuery/EnumQuery").
		Methods("GET").
		Path("/v1/enum").
		Handler(handler.EnumQuery())
	return router
}

type enumQueryGorillaHandler struct {
	service      EnumQueryGorillaService
	decoder      enumQueryGorillaRequestDecoder
	encoder      enumQueryGorillaResponseEncoder
	errorEncoder v2.ErrorEncoder
}

func (h enumQueryGorillaHandler) EnumQuery() http.Handler {
	return http.HandlerFunc(func(writer http.ResponseWriter, request *http.Request) {
		ctx := request.Context()
		in, err := h.decoder.EnumQuery(ctx, request)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		out, err := h.service.EnumQuery(ctx, in)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		if err := h.encoder.EnumQuery(ctx, writer, out); err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
	})
}

type enumQueryGorillaRequestDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder enumQueryGorillaRequestDecoder) EnumQuery(ctx context.Context, r *http.Request) (*EnumQueryRequest, error) {
	req := &EnumQueryRequest{}
	queries := r.URL.Query()
	var queryErr error
	req.Status, queryErr = v2.FormDecoder[EnumQueryRequest_Status](queryErr, queries, "status", urlx.GetInt[EnumQueryRequest_Status])
	req.OptStatus, queryErr = v2.FormDecoder[*EnumQueryRequest_Status](queryErr, queries, "opt_status", urlx.GetIntPtr[EnumQueryRequest_Status])
	if queryErr != nil {
		return nil, queryErr
	}
	return req, nil
}

type enumQueryGorillaResponseEncoder struct {
	marshalOptions      protojson.MarshalOptions
	unmarshalOptions    protojson.UnmarshalOptions
	responseTransformer v2.ResponseTransformer
}

func (encoder enumQueryGorillaResponseEncoder) EnumQuery(ctx context.Context, w http.ResponseWriter, resp *emptypb.Empty) error {
	return v2.ResponseEncoder(ctx, w, encoder.responseTransformer(ctx, resp), encoder.marshalOptions)
}
