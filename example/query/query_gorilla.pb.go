// Code generated by protoc-gen-gors. DO NOT EDIT.

package query

import (
	context "context"
	gorilla "github.com/go-leo/gorilla"
	mux "github.com/gorilla/mux"
	protojson "google.golang.org/protobuf/encoding/protojson"
	proto "google.golang.org/protobuf/proto"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
	wrapperspb "google.golang.org/protobuf/types/known/wrapperspb"
	http "net/http"
)

type BoolQueryGorsService interface {
	BoolQuery(ctx context.Context, request *BoolQueryRequest) (*emptypb.Empty, error)
}

func AppendBoolQueryGorsRoute(router *mux.Router, service BoolQueryGorsService, opts ...gorilla.Option) *mux.Router {
	options := gorilla.NewOptions(opts...)
	handler := boolQueryGorsHandler{
		service: service,
		decoder: boolQueryGorsRequestDecoder{
			unmarshalOptions: options.UnmarshalOptions(),
		},
		encoder: boolQueryGorsResponseEncoder{
			marshalOptions:      options.MarshalOptions(),
			unmarshalOptions:    options.UnmarshalOptions(),
			responseTransformer: options.ResponseTransformer(),
		},
		errorEncoder: gorilla.DefaultErrorEncoder,
	}
	router.NewRoute().
		Name("/leo.gorilla.example.query.v1.BoolQuery/BoolQuery").
		Methods("GET").
		Path("/v1/bool").
		Handler(handler.BoolQuery())
	return router
}

type boolQueryGorsHandler struct {
	service      BoolQueryGorsService
	decoder      boolQueryGorsRequestDecoder
	encoder      boolQueryGorsResponseEncoder
	errorEncoder gorilla.ErrorEncoder
}

func (h boolQueryGorsHandler) BoolQuery() http.Handler {
	return http.HandlerFunc(func(writer http.ResponseWriter, request *http.Request) {
		ctx := request.Context()
		in, err := h.decoder.BoolQuery(ctx, request)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		out, err := h.service.BoolQuery(ctx, in)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		if err := h.encoder.BoolQuery(ctx, writer, out); err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
	})
}

type boolQueryGorsRequestDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder boolQueryGorsRequestDecoder) BoolQuery(ctx context.Context, r *http.Request) (*BoolQueryRequest, error) {
	req := &BoolQueryRequest{}
	queries := r.URL.Query()
	var queryErr error
	req.Bool, queryErr = gorilla.FormDecoder[bool](queryErr, queries, "bool", gorilla.GetBool)
	req.OptBool, queryErr = gorilla.FormDecoder[*bool](queryErr, queries, "opt_bool", gorilla.GetBoolPtr)
	req.WrapBool, queryErr = gorilla.FormDecoder[*wrapperspb.BoolValue](queryErr, queries, "wrap_bool", gorilla.GetBoolValue)
	if queryErr != nil {
		return nil, queryErr
	}
	return req, nil
}

type boolQueryGorsResponseEncoder struct {
	marshalOptions      protojson.MarshalOptions
	unmarshalOptions    protojson.UnmarshalOptions
	responseTransformer gorilla.ResponseTransformer
}

func (encoder boolQueryGorsResponseEncoder) BoolQuery(ctx context.Context, w http.ResponseWriter, resp *emptypb.Empty) error {
	return gorilla.ResponseEncoder(ctx, w, encoder.responseTransformer(ctx, resp), encoder.marshalOptions)
}

type Int32QueryGorsService interface {
	Int32Query(ctx context.Context, request *Int32QueryRequest) (*emptypb.Empty, error)
}

func AppendInt32QueryGorsRoute(router *mux.Router, service Int32QueryGorsService, opts ...gorilla.Option) *mux.Router {
	options := gorilla.NewOptions(opts...)
	handler := int32QueryGorsHandler{
		service: service,
		decoder: int32QueryGorsRequestDecoder{
			unmarshalOptions: options.UnmarshalOptions(),
		},
		encoder: int32QueryGorsResponseEncoder{
			marshalOptions:      options.MarshalOptions(),
			unmarshalOptions:    options.UnmarshalOptions(),
			responseTransformer: options.ResponseTransformer(),
		},
		errorEncoder: gorilla.DefaultErrorEncoder,
	}
	router.NewRoute().
		Name("/leo.gorilla.example.query.v1.Int32Query/Int32Query").
		Methods("GET").
		Path("/v1/int32").
		Handler(handler.Int32Query())
	return router
}

type int32QueryGorsHandler struct {
	service      Int32QueryGorsService
	decoder      int32QueryGorsRequestDecoder
	encoder      int32QueryGorsResponseEncoder
	errorEncoder gorilla.ErrorEncoder
}

func (h int32QueryGorsHandler) Int32Query() http.Handler {
	return http.HandlerFunc(func(writer http.ResponseWriter, request *http.Request) {
		ctx := request.Context()
		in, err := h.decoder.Int32Query(ctx, request)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		out, err := h.service.Int32Query(ctx, in)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		if err := h.encoder.Int32Query(ctx, writer, out); err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
	})
}

type int32QueryGorsRequestDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder int32QueryGorsRequestDecoder) Int32Query(ctx context.Context, r *http.Request) (*Int32QueryRequest, error) {
	req := &Int32QueryRequest{}
	queries := r.URL.Query()
	var queryErr error
	req.Int32, queryErr = gorilla.FormDecoder[int32](queryErr, queries, "int32", gorilla.GetInt32)
	req.Sint32, queryErr = gorilla.FormDecoder[int32](queryErr, queries, "sint32", gorilla.GetInt32)
	req.Sfixed32, queryErr = gorilla.FormDecoder[int32](queryErr, queries, "sfixed32", gorilla.GetInt32)
	req.OptInt32, queryErr = gorilla.FormDecoder[*int32](queryErr, queries, "opt_int32", gorilla.GetInt32Ptr)
	req.OptSint32, queryErr = gorilla.FormDecoder[*int32](queryErr, queries, "opt_sint32", gorilla.GetInt32Ptr)
	req.OptSfixed32, queryErr = gorilla.FormDecoder[*int32](queryErr, queries, "opt_sfixed32", gorilla.GetInt32Ptr)
	req.WrapInt32, queryErr = gorilla.FormDecoder[*wrapperspb.Int32Value](queryErr, queries, "wrap_int32", gorilla.GetInt32Value)
	if queryErr != nil {
		return nil, queryErr
	}
	return req, nil
}

type int32QueryGorsResponseEncoder struct {
	marshalOptions      protojson.MarshalOptions
	unmarshalOptions    protojson.UnmarshalOptions
	responseTransformer gorilla.ResponseTransformer
}

func (encoder int32QueryGorsResponseEncoder) Int32Query(ctx context.Context, w http.ResponseWriter, resp *emptypb.Empty) error {
	return gorilla.ResponseEncoder(ctx, w, encoder.responseTransformer(ctx, resp), encoder.marshalOptions)
}

type Int64QueryGorsService interface {
	Int64Query(ctx context.Context, request *Int64QueryRequest) (*emptypb.Empty, error)
}

func AppendInt64QueryGorsRoute(router *mux.Router, service Int64QueryGorsService, opts ...gorilla.Option) *mux.Router {
	options := gorilla.NewOptions(opts...)
	handler := int64QueryGorsHandler{
		service: service,
		decoder: int64QueryGorsRequestDecoder{
			unmarshalOptions: options.UnmarshalOptions(),
		},
		encoder: int64QueryGorsResponseEncoder{
			marshalOptions:      options.MarshalOptions(),
			unmarshalOptions:    options.UnmarshalOptions(),
			responseTransformer: options.ResponseTransformer(),
		},
		errorEncoder: gorilla.DefaultErrorEncoder,
	}
	router.NewRoute().
		Name("/leo.gorilla.example.query.v1.Int64Query/Int64Query").
		Methods("GET").
		Path("/v1/int64").
		Handler(handler.Int64Query())
	return router
}

type int64QueryGorsHandler struct {
	service      Int64QueryGorsService
	decoder      int64QueryGorsRequestDecoder
	encoder      int64QueryGorsResponseEncoder
	errorEncoder gorilla.ErrorEncoder
}

func (h int64QueryGorsHandler) Int64Query() http.Handler {
	return http.HandlerFunc(func(writer http.ResponseWriter, request *http.Request) {
		ctx := request.Context()
		in, err := h.decoder.Int64Query(ctx, request)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		out, err := h.service.Int64Query(ctx, in)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		if err := h.encoder.Int64Query(ctx, writer, out); err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
	})
}

type int64QueryGorsRequestDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder int64QueryGorsRequestDecoder) Int64Query(ctx context.Context, r *http.Request) (*Int64QueryRequest, error) {
	req := &Int64QueryRequest{}
	queries := r.URL.Query()
	var queryErr error
	req.Int64, queryErr = gorilla.FormDecoder[int64](queryErr, queries, "int64", gorilla.GetInt64)
	req.Sint64, queryErr = gorilla.FormDecoder[int64](queryErr, queries, "sint64", gorilla.GetInt64)
	req.Sfixed64, queryErr = gorilla.FormDecoder[int64](queryErr, queries, "sfixed64", gorilla.GetInt64)
	req.OptInt64, queryErr = gorilla.FormDecoder[*int64](queryErr, queries, "opt_int64", gorilla.GetInt64Ptr)
	req.OptSint64, queryErr = gorilla.FormDecoder[*int64](queryErr, queries, "opt_sint64", gorilla.GetInt64Ptr)
	req.OptSfixed64, queryErr = gorilla.FormDecoder[*int64](queryErr, queries, "opt_sfixed64", gorilla.GetInt64Ptr)
	req.WrapInt64, queryErr = gorilla.FormDecoder[*wrapperspb.Int64Value](queryErr, queries, "wrap_int64", gorilla.GetInt64Value)
	if queryErr != nil {
		return nil, queryErr
	}
	return req, nil
}

type int64QueryGorsResponseEncoder struct {
	marshalOptions      protojson.MarshalOptions
	unmarshalOptions    protojson.UnmarshalOptions
	responseTransformer gorilla.ResponseTransformer
}

func (encoder int64QueryGorsResponseEncoder) Int64Query(ctx context.Context, w http.ResponseWriter, resp *emptypb.Empty) error {
	return gorilla.ResponseEncoder(ctx, w, encoder.responseTransformer(ctx, resp), encoder.marshalOptions)
}

type Uint32QueryGorsService interface {
	Uint32Query(ctx context.Context, request *Uint32QueryRequest) (*emptypb.Empty, error)
}

func AppendUint32QueryGorsRoute(router *mux.Router, service Uint32QueryGorsService, opts ...gorilla.Option) *mux.Router {
	options := gorilla.NewOptions(opts...)
	handler := uint32QueryGorsHandler{
		service: service,
		decoder: uint32QueryGorsRequestDecoder{
			unmarshalOptions: options.UnmarshalOptions(),
		},
		encoder: uint32QueryGorsResponseEncoder{
			marshalOptions:      options.MarshalOptions(),
			unmarshalOptions:    options.UnmarshalOptions(),
			responseTransformer: options.ResponseTransformer(),
		},
		errorEncoder: gorilla.DefaultErrorEncoder,
	}
	router.NewRoute().
		Name("/leo.gorilla.example.query.v1.Uint32Query/Uint32Query").
		Methods("GET").
		Path("/v1/uint32").
		Handler(handler.Uint32Query())
	return router
}

type uint32QueryGorsHandler struct {
	service      Uint32QueryGorsService
	decoder      uint32QueryGorsRequestDecoder
	encoder      uint32QueryGorsResponseEncoder
	errorEncoder gorilla.ErrorEncoder
}

func (h uint32QueryGorsHandler) Uint32Query() http.Handler {
	return http.HandlerFunc(func(writer http.ResponseWriter, request *http.Request) {
		ctx := request.Context()
		in, err := h.decoder.Uint32Query(ctx, request)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		out, err := h.service.Uint32Query(ctx, in)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		if err := h.encoder.Uint32Query(ctx, writer, out); err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
	})
}

type uint32QueryGorsRequestDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder uint32QueryGorsRequestDecoder) Uint32Query(ctx context.Context, r *http.Request) (*Uint32QueryRequest, error) {
	req := &Uint32QueryRequest{}
	queries := r.URL.Query()
	var queryErr error
	req.Uint32, queryErr = gorilla.FormDecoder[uint32](queryErr, queries, "uint32", gorilla.GetUint32)
	req.Fixed32, queryErr = gorilla.FormDecoder[uint32](queryErr, queries, "fixed32", gorilla.GetUint32)
	req.OptUint32, queryErr = gorilla.FormDecoder[*uint32](queryErr, queries, "opt_uint32", gorilla.GetUint32Ptr)
	req.OptFixed32, queryErr = gorilla.FormDecoder[*uint32](queryErr, queries, "opt_fixed32", gorilla.GetUint32Ptr)
	req.WrapUint32, queryErr = gorilla.FormDecoder[*wrapperspb.UInt32Value](queryErr, queries, "wrap_uint32", gorilla.GetUint32Value)
	if queryErr != nil {
		return nil, queryErr
	}
	return req, nil
}

type uint32QueryGorsResponseEncoder struct {
	marshalOptions      protojson.MarshalOptions
	unmarshalOptions    protojson.UnmarshalOptions
	responseTransformer gorilla.ResponseTransformer
}

func (encoder uint32QueryGorsResponseEncoder) Uint32Query(ctx context.Context, w http.ResponseWriter, resp *emptypb.Empty) error {
	return gorilla.ResponseEncoder(ctx, w, encoder.responseTransformer(ctx, resp), encoder.marshalOptions)
}

type Uint64QueryGorsService interface {
	Uint64Query(ctx context.Context, request *Uint64QueryRequest) (*emptypb.Empty, error)
}

func AppendUint64QueryGorsRoute(router *mux.Router, service Uint64QueryGorsService, opts ...gorilla.Option) *mux.Router {
	options := gorilla.NewOptions(opts...)
	handler := uint64QueryGorsHandler{
		service: service,
		decoder: uint64QueryGorsRequestDecoder{
			unmarshalOptions: options.UnmarshalOptions(),
		},
		encoder: uint64QueryGorsResponseEncoder{
			marshalOptions:      options.MarshalOptions(),
			unmarshalOptions:    options.UnmarshalOptions(),
			responseTransformer: options.ResponseTransformer(),
		},
		errorEncoder: gorilla.DefaultErrorEncoder,
	}
	router.NewRoute().
		Name("/leo.gorilla.example.query.v1.Uint64Query/Uint64Query").
		Methods("GET").
		Path("/v1/uint64").
		Handler(handler.Uint64Query())
	return router
}

type uint64QueryGorsHandler struct {
	service      Uint64QueryGorsService
	decoder      uint64QueryGorsRequestDecoder
	encoder      uint64QueryGorsResponseEncoder
	errorEncoder gorilla.ErrorEncoder
}

func (h uint64QueryGorsHandler) Uint64Query() http.Handler {
	return http.HandlerFunc(func(writer http.ResponseWriter, request *http.Request) {
		ctx := request.Context()
		in, err := h.decoder.Uint64Query(ctx, request)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		out, err := h.service.Uint64Query(ctx, in)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		if err := h.encoder.Uint64Query(ctx, writer, out); err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
	})
}

type uint64QueryGorsRequestDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder uint64QueryGorsRequestDecoder) Uint64Query(ctx context.Context, r *http.Request) (*Uint64QueryRequest, error) {
	req := &Uint64QueryRequest{}
	queries := r.URL.Query()
	var queryErr error
	req.Uint64, queryErr = gorilla.FormDecoder[uint64](queryErr, queries, "uint64", gorilla.GetUint64)
	req.Fixed64, queryErr = gorilla.FormDecoder[uint64](queryErr, queries, "fixed64", gorilla.GetUint64)
	req.OptUint64, queryErr = gorilla.FormDecoder[*uint64](queryErr, queries, "opt_uint64", gorilla.GetUint64Ptr)
	req.OptFixed64, queryErr = gorilla.FormDecoder[*uint64](queryErr, queries, "opt_fixed64", gorilla.GetUint64Ptr)
	req.WrapUint64, queryErr = gorilla.FormDecoder[*wrapperspb.UInt64Value](queryErr, queries, "wrap_uint64", gorilla.GetUint64Value)
	if queryErr != nil {
		return nil, queryErr
	}
	return req, nil
}

type uint64QueryGorsResponseEncoder struct {
	marshalOptions      protojson.MarshalOptions
	unmarshalOptions    protojson.UnmarshalOptions
	responseTransformer gorilla.ResponseTransformer
}

func (encoder uint64QueryGorsResponseEncoder) Uint64Query(ctx context.Context, w http.ResponseWriter, resp *emptypb.Empty) error {
	return gorilla.ResponseEncoder(ctx, w, encoder.responseTransformer(ctx, resp), encoder.marshalOptions)
}

type FloatQueryGorsService interface {
	FloatQuery(ctx context.Context, request *FloatQueryRequest) (*emptypb.Empty, error)
}

func AppendFloatQueryGorsRoute(router *mux.Router, service FloatQueryGorsService, opts ...gorilla.Option) *mux.Router {
	options := gorilla.NewOptions(opts...)
	handler := floatQueryGorsHandler{
		service: service,
		decoder: floatQueryGorsRequestDecoder{
			unmarshalOptions: options.UnmarshalOptions(),
		},
		encoder: floatQueryGorsResponseEncoder{
			marshalOptions:      options.MarshalOptions(),
			unmarshalOptions:    options.UnmarshalOptions(),
			responseTransformer: options.ResponseTransformer(),
		},
		errorEncoder: gorilla.DefaultErrorEncoder,
	}
	router.NewRoute().
		Name("/leo.gorilla.example.query.v1.FloatQuery/FloatQuery").
		Methods("GET").
		Path("/v1/float").
		Handler(handler.FloatQuery())
	return router
}

type floatQueryGorsHandler struct {
	service      FloatQueryGorsService
	decoder      floatQueryGorsRequestDecoder
	encoder      floatQueryGorsResponseEncoder
	errorEncoder gorilla.ErrorEncoder
}

func (h floatQueryGorsHandler) FloatQuery() http.Handler {
	return http.HandlerFunc(func(writer http.ResponseWriter, request *http.Request) {
		ctx := request.Context()
		in, err := h.decoder.FloatQuery(ctx, request)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		out, err := h.service.FloatQuery(ctx, in)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		if err := h.encoder.FloatQuery(ctx, writer, out); err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
	})
}

type floatQueryGorsRequestDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder floatQueryGorsRequestDecoder) FloatQuery(ctx context.Context, r *http.Request) (*FloatQueryRequest, error) {
	req := &FloatQueryRequest{}
	queries := r.URL.Query()
	var queryErr error
	req.Float, queryErr = gorilla.FormDecoder[float32](queryErr, queries, "float", gorilla.GetFloat32)
	req.OptFloat, queryErr = gorilla.FormDecoder[*float32](queryErr, queries, "opt_float", gorilla.GetFloat32Ptr)
	req.WrapFloat, queryErr = gorilla.FormDecoder[*wrapperspb.FloatValue](queryErr, queries, "wrap_float", gorilla.GetFloat32Value)
	if queryErr != nil {
		return nil, queryErr
	}
	return req, nil
}

type floatQueryGorsResponseEncoder struct {
	marshalOptions      protojson.MarshalOptions
	unmarshalOptions    protojson.UnmarshalOptions
	responseTransformer gorilla.ResponseTransformer
}

func (encoder floatQueryGorsResponseEncoder) FloatQuery(ctx context.Context, w http.ResponseWriter, resp *emptypb.Empty) error {
	return gorilla.ResponseEncoder(ctx, w, encoder.responseTransformer(ctx, resp), encoder.marshalOptions)
}

type DoubleQueryGorsService interface {
	DoubleQuery(ctx context.Context, request *DoubleQueryRequest) (*emptypb.Empty, error)
}

func AppendDoubleQueryGorsRoute(router *mux.Router, service DoubleQueryGorsService, opts ...gorilla.Option) *mux.Router {
	options := gorilla.NewOptions(opts...)
	handler := doubleQueryGorsHandler{
		service: service,
		decoder: doubleQueryGorsRequestDecoder{
			unmarshalOptions: options.UnmarshalOptions(),
		},
		encoder: doubleQueryGorsResponseEncoder{
			marshalOptions:      options.MarshalOptions(),
			unmarshalOptions:    options.UnmarshalOptions(),
			responseTransformer: options.ResponseTransformer(),
		},
		errorEncoder: gorilla.DefaultErrorEncoder,
	}
	router.NewRoute().
		Name("/leo.gorilla.example.query.v1.DoubleQuery/DoubleQuery").
		Methods("GET").
		Path("/v1/double").
		Handler(handler.DoubleQuery())
	return router
}

type doubleQueryGorsHandler struct {
	service      DoubleQueryGorsService
	decoder      doubleQueryGorsRequestDecoder
	encoder      doubleQueryGorsResponseEncoder
	errorEncoder gorilla.ErrorEncoder
}

func (h doubleQueryGorsHandler) DoubleQuery() http.Handler {
	return http.HandlerFunc(func(writer http.ResponseWriter, request *http.Request) {
		ctx := request.Context()
		in, err := h.decoder.DoubleQuery(ctx, request)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		out, err := h.service.DoubleQuery(ctx, in)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		if err := h.encoder.DoubleQuery(ctx, writer, out); err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
	})
}

type doubleQueryGorsRequestDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder doubleQueryGorsRequestDecoder) DoubleQuery(ctx context.Context, r *http.Request) (*DoubleQueryRequest, error) {
	req := &DoubleQueryRequest{}
	queries := r.URL.Query()
	var queryErr error
	req.Double, queryErr = gorilla.FormDecoder[float64](queryErr, queries, "double", gorilla.GetFloat64)
	req.OptDouble, queryErr = gorilla.FormDecoder[*float64](queryErr, queries, "opt_double", gorilla.GetFloat64Ptr)
	req.WrapDouble, queryErr = gorilla.FormDecoder[*wrapperspb.DoubleValue](queryErr, queries, "wrap_double", gorilla.GetFloat64Value)
	if queryErr != nil {
		return nil, queryErr
	}
	return req, nil
}

type doubleQueryGorsResponseEncoder struct {
	marshalOptions      protojson.MarshalOptions
	unmarshalOptions    protojson.UnmarshalOptions
	responseTransformer gorilla.ResponseTransformer
}

func (encoder doubleQueryGorsResponseEncoder) DoubleQuery(ctx context.Context, w http.ResponseWriter, resp *emptypb.Empty) error {
	return gorilla.ResponseEncoder(ctx, w, encoder.responseTransformer(ctx, resp), encoder.marshalOptions)
}

type StringQueryGorsService interface {
	StringQuery(ctx context.Context, request *StringQueryRequest) (*emptypb.Empty, error)
}

func AppendStringQueryGorsRoute(router *mux.Router, service StringQueryGorsService, opts ...gorilla.Option) *mux.Router {
	options := gorilla.NewOptions(opts...)
	handler := stringQueryGorsHandler{
		service: service,
		decoder: stringQueryGorsRequestDecoder{
			unmarshalOptions: options.UnmarshalOptions(),
		},
		encoder: stringQueryGorsResponseEncoder{
			marshalOptions:      options.MarshalOptions(),
			unmarshalOptions:    options.UnmarshalOptions(),
			responseTransformer: options.ResponseTransformer(),
		},
		errorEncoder: gorilla.DefaultErrorEncoder,
	}
	router.NewRoute().
		Name("/leo.gorilla.example.query.v1.StringQuery/StringQuery").
		Methods("GET").
		Path("/v1/string").
		Handler(handler.StringQuery())
	return router
}

type stringQueryGorsHandler struct {
	service      StringQueryGorsService
	decoder      stringQueryGorsRequestDecoder
	encoder      stringQueryGorsResponseEncoder
	errorEncoder gorilla.ErrorEncoder
}

func (h stringQueryGorsHandler) StringQuery() http.Handler {
	return http.HandlerFunc(func(writer http.ResponseWriter, request *http.Request) {
		ctx := request.Context()
		in, err := h.decoder.StringQuery(ctx, request)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		out, err := h.service.StringQuery(ctx, in)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		if err := h.encoder.StringQuery(ctx, writer, out); err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
	})
}

type stringQueryGorsRequestDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder stringQueryGorsRequestDecoder) StringQuery(ctx context.Context, r *http.Request) (*StringQueryRequest, error) {
	req := &StringQueryRequest{}
	queries := r.URL.Query()
	var queryErr error
	req.String_ = queries.Get("string")
	req.OptString = proto.String(queries.Get("opt_string"))
	req.WrapString = wrapperspb.String(queries.Get("wrap_string"))
	if queryErr != nil {
		return nil, queryErr
	}
	return req, nil
}

type stringQueryGorsResponseEncoder struct {
	marshalOptions      protojson.MarshalOptions
	unmarshalOptions    protojson.UnmarshalOptions
	responseTransformer gorilla.ResponseTransformer
}

func (encoder stringQueryGorsResponseEncoder) StringQuery(ctx context.Context, w http.ResponseWriter, resp *emptypb.Empty) error {
	return gorilla.ResponseEncoder(ctx, w, encoder.responseTransformer(ctx, resp), encoder.marshalOptions)
}

type EnumQueryGorsService interface {
	EnumQuery(ctx context.Context, request *EnumQueryRequest) (*emptypb.Empty, error)
}

func AppendEnumQueryGorsRoute(router *mux.Router, service EnumQueryGorsService, opts ...gorilla.Option) *mux.Router {
	options := gorilla.NewOptions(opts...)
	handler := enumQueryGorsHandler{
		service: service,
		decoder: enumQueryGorsRequestDecoder{
			unmarshalOptions: options.UnmarshalOptions(),
		},
		encoder: enumQueryGorsResponseEncoder{
			marshalOptions:      options.MarshalOptions(),
			unmarshalOptions:    options.UnmarshalOptions(),
			responseTransformer: options.ResponseTransformer(),
		},
		errorEncoder: gorilla.DefaultErrorEncoder,
	}
	router.NewRoute().
		Name("/leo.gorilla.example.query.v1.EnumQuery/EnumQuery").
		Methods("GET").
		Path("/v1/enum").
		Handler(handler.EnumQuery())
	return router
}

type enumQueryGorsHandler struct {
	service      EnumQueryGorsService
	decoder      enumQueryGorsRequestDecoder
	encoder      enumQueryGorsResponseEncoder
	errorEncoder gorilla.ErrorEncoder
}

func (h enumQueryGorsHandler) EnumQuery() http.Handler {
	return http.HandlerFunc(func(writer http.ResponseWriter, request *http.Request) {
		ctx := request.Context()
		in, err := h.decoder.EnumQuery(ctx, request)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		out, err := h.service.EnumQuery(ctx, in)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		if err := h.encoder.EnumQuery(ctx, writer, out); err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
	})
}

type enumQueryGorsRequestDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder enumQueryGorsRequestDecoder) EnumQuery(ctx context.Context, r *http.Request) (*EnumQueryRequest, error) {
	req := &EnumQueryRequest{}
	queries := r.URL.Query()
	var queryErr error
	req.Status, queryErr = gorilla.FormDecoder[EnumQueryRequest_Status](queryErr, queries, "status", gorilla.GetInt[EnumQueryRequest_Status])
	req.OptStatus, queryErr = gorilla.FormDecoder[*EnumQueryRequest_Status](queryErr, queries, "opt_status", gorilla.GetIntPtr[EnumQueryRequest_Status])
	if queryErr != nil {
		return nil, queryErr
	}
	return req, nil
}

type enumQueryGorsResponseEncoder struct {
	marshalOptions      protojson.MarshalOptions
	unmarshalOptions    protojson.UnmarshalOptions
	responseTransformer gorilla.ResponseTransformer
}

func (encoder enumQueryGorsResponseEncoder) EnumQuery(ctx context.Context, w http.ResponseWriter, resp *emptypb.Empty) error {
	return gorilla.ResponseEncoder(ctx, w, encoder.responseTransformer(ctx, resp), encoder.marshalOptions)
}
